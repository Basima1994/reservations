{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { intersects } from '../utils';\nimport { ZonedDate, MS_PER_DAY } from '@progress/kendo-date-math';\nimport { orderBy } from '@progress/kendo-data-query';\nimport { EMPTY_RESOURCE } from '../constants';\nimport { expandResources, toGroupResources } from '../views/common/utils';\n/** @hidden */\n\nexport var toDaySlots = function (group, resources, ranges, timezone, props) {\n  var slots = [];\n  var groupResources = toGroupResources(group, resources);\n  var expandedResources = expandResources(groupResources || [], (groupResources || []).length - 1);\n  var hasGroups = expandedResources.length > 0;\n  (hasGroups ? expandedResources : EMPTY_RESOURCE).forEach(function (_, groupIndex) {\n    return ranges.forEach(function (range, rangeIndex) {\n      generateDaySlots(range.start, range.end, timezone, props).forEach(function (daySlot) {\n        slots.push(__assign({}, daySlot, {\n          groupIndex: hasGroups ? groupIndex : undefined,\n          rangeIndex: rangeIndex\n        }));\n      });\n    });\n  });\n  return slots;\n};\n/** @hidden */\n\nexport var toDayItems = function (_a) {\n  var rangeStart = _a.rangeStart,\n      rangeEnd = _a.rangeEnd,\n      timezone = _a.timezone,\n      data = _a.data,\n      ranges = _a.ranges;\n  var items = [];\n  var sorted = orderBy(data, [{\n    field: 'isAllDay',\n    dir: 'desc'\n  }, {\n    field: 'start',\n    dir: 'asc'\n  }, {\n    field: 'end',\n    dir: 'desc'\n  }]);\n\n  for (var index = 0; index < sorted.length; index++) {\n    var item = toDayItem(sorted[index], {\n      timezone: timezone,\n      ranges: ranges,\n      rangeStart: rangeStart,\n      rangeEnd: rangeEnd\n    });\n\n    if (item) {\n      items.push(item);\n    }\n  }\n\n  return items;\n};\n/** @hidden */\n\nexport var toDayItem = function (item, _a) {\n  var timezone = _a.timezone,\n      ranges = _a.ranges,\n      rangeStart = _a.rangeStart,\n      rangeEnd = _a.rangeEnd;\n  var isRecurring = Boolean(item.recurrenceRule);\n  var isException = item.recurrenceId !== undefined && item.recurrenceId !== null && !isRecurring;\n  var isAllDay = Boolean(item.isAllDay); // || (!inEdit && isMultiDay(eventItem.dataItem));\n\n  if (intersects(item.start, item.end, rangeStart, rangeEnd)) {\n    var ref = React.createRef();\n    var zonedStart = ZonedDate.fromLocalDate(item.start, timezone);\n    var zonedEnd = ZonedDate.fromLocalDate(item.end, timezone);\n\n    var viewItem = __assign({}, item, {\n      ref: ref,\n      order: null,\n      slots: [],\n      ranges: ranges.filter(function (range) {\n        return intersects(item.start, item.end, range.start, range.end);\n      }),\n      zonedStart: zonedStart,\n      zonedEnd: zonedEnd,\n      isAllDay: isAllDay,\n      isEdge: true,\n      isException: isException,\n      isRecurring: isRecurring,\n      head: item.end > rangeEnd,\n      tail: item.start < rangeStart\n    });\n\n    return viewItem;\n  }\n\n  return null;\n};\n/** @hidden */\n\nexport var generateDaySlots = function (rangeStart, rangeEnd, timezone, _a) {\n  var workWeekStart = _a.workWeekStart,\n      workWeekEnd = _a.workWeekEnd;\n  var startTime = rangeStart.getTime();\n  var endTime = rangeEnd.getTime();\n  var slots = [];\n  var base = startTime;\n  var step = MS_PER_DAY;\n  var total = endTime - startTime;\n  var index = 0;\n  var distance = 0;\n\n  while (distance < total) {\n    var ref = React.createRef();\n    var start = new Date(base + index * step);\n    var zonedStart = ZonedDate.fromLocalDate(start, timezone);\n    var end = new Date(base + (index + 1) * step);\n    var zonedEnd = ZonedDate.fromLocalDate(end, timezone);\n    var workDay = workWeekStart !== undefined && workWeekEnd !== undefined && workWeekStart <= zonedStart.getDay() && zonedEnd.getDay() <= workWeekEnd;\n    var slot = {\n      ref: ref,\n      end: end,\n      start: start,\n      zonedStart: zonedStart,\n      zonedEnd: zonedEnd,\n      index: index,\n      items: [],\n      workHour: false,\n      workDay: workDay,\n      isAllDay: true,\n      isMajor: true,\n      isEdge: false,\n      rangeIndex: 0,\n      groupIndex: 0\n    };\n    index++;\n    distance += step;\n    slots.push(slot);\n  }\n\n  return slots;\n};\n/** @hidden */\n\nexport var toDayRanges = generateDaySlots;","map":null,"metadata":{},"sourceType":"module"}