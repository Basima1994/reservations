{"ast":null,"code":"import { MS_PER_HOUR, MS_PER_MINUTE, ZonedDate } from '@progress/kendo-date-math';\nimport { DailyFrequency, HourlyFrequency, MonthlyFrequency, WeeklyFrequency, YearlyFrequency } from './frequencies';\nimport { duration, setDayOfWeek } from './utils';\nvar frequencies = {\n  'hourly': new HourlyFrequency(),\n  'daily': new DailyFrequency(),\n  'weekly': new WeeklyFrequency(),\n  'monthly': new MonthlyFrequency(),\n  'yearly': new YearlyFrequency()\n}; // Normally, ZonedDate will allow creating an instance at the\n// missing DST hour in the time zone.\n// This is useful during recurrence calculations.\n//\n// By doing a round-trip through toLocalDate(), the missing\n// DST hour is replaced with a valid time.\n\nvar normalizeDST = function (date) {\n  return ZonedDate.fromLocalDate(date.toLocalDate(), date.timezone);\n};\n\nvar getTimeAfterMidnight = function (date) {\n  return date.getHours() * MS_PER_HOUR + date.getMinutes() * MS_PER_MINUTE + date.getSeconds() * 1000 + date.getMilliseconds();\n};\n\nvar isException = function (exceptions, date) {\n  if (!exceptions) {\n    return false;\n  }\n\n  var dateTime = date.getTime() - date.getMilliseconds();\n  var length = exceptions.length;\n\n  for (var idx = 0; idx < length; idx++) {\n    if (exceptions[idx].getTime() === dateTime) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar startPeriodByFreq = function (start, rule) {\n  var date = start.toUTCDate();\n\n  switch (rule.freq) {\n    case 'yearly':\n      date.setUTCFullYear(date.getFullYear(), 0, 1);\n      break;\n\n    case 'monthly':\n      date.setUTCFullYear(date.getFullYear(), date.getMonth(), 1);\n      break;\n\n    case 'weekly':\n      setDayOfWeek(date, rule.weekStart, -1);\n      break;\n\n    default:\n      break;\n  }\n\n  if (rule.byHour) {\n    date.setUTCHours(0);\n  }\n\n  if (rule.byMinute) {\n    date.setUTCMinutes(0);\n  }\n\n  if (rule.bySecond) {\n    date.setUTCSeconds(0);\n  }\n\n  return ZonedDate.fromUTCDate(date, start.timezone);\n};\n\nvar endPeriodByFreq = function (start, rule) {\n  var date = start.toUTCDate();\n\n  switch (rule.freq) {\n    case 'yearly':\n      date.setUTCFullYear(date.getUTCFullYear(), 11, 31);\n      break;\n\n    case 'monthly':\n      date.setUTCFullYear(date.getUTCFullYear(), date.getUTCMonth() + 1, 0);\n      break;\n\n    case 'weekly':\n      setDayOfWeek(date, rule.weekStart, -1);\n      date.setUTCDate(date.getUTCDate() + 6);\n      break;\n\n    default:\n      break;\n  }\n\n  if (rule.byHour) {\n    date.setUTCHours(23);\n  }\n\n  if (rule.byMinute) {\n    date.setUTCMinutes(59);\n  }\n\n  if (rule.bySecond) {\n    date.setUTCSeconds(59);\n  }\n\n  return ZonedDate.fromUTCDate(date, start.timezone);\n};\n\nvar eventsByPosition = function (periodEvents, start, positions) {\n  var periodEventsLength = periodEvents.length;\n  var events = [];\n  var position;\n\n  for (var idx = 0, length_1 = positions.length; idx < length_1; idx++) {\n    position = positions[idx];\n\n    if (position < 0) {\n      position = periodEventsLength + position;\n    } else {\n      position -= 1; //convert to zero based index\n    }\n\n    var event_1 = periodEvents[position];\n\n    if (event_1 && event_1.start >= start) {\n      events.push(event_1);\n    }\n  }\n\n  return events;\n};\n\nvar removeExceptionDates = function (periodEvents, exceptionDates) {\n  var events = [];\n\n  for (var idx = 0; idx < periodEvents.length; idx++) {\n    var event_2 = periodEvents[idx];\n\n    if (event_2 && !isException(exceptionDates, event_2.start)) {\n      events.push(event_2);\n    }\n  }\n\n  return events;\n};\n/**\n * Expands a recurrence rule into individual events in the specified time range.\n *\n * @param rule The recurrence rule to expand.\n * @param options Configuration options for the expand operation.\n * @return ExpandResult The result of the operation. If successful, the events field will contain the events.\n */\n\n\nexport function expand(rule, options) {\n  var rangeStart = options.rangeStart,\n      rangeEnd = options.rangeEnd;\n\n  if (!rule) {\n    return {\n      success: true,\n      errorMessage: '',\n      events: []\n    };\n  }\n\n  var freqName = rule.freq;\n  var freq = frequencies[freqName];\n  var eventStart = rule.start;\n  var eventDuration = duration(rule.start, rule.end);\n  var endPeriod;\n\n  if (rule.start.getTime() > rule.end.getTime()) {\n    return {\n      success: false,\n      errorMessage: \"Invalid recurrence rule: Start date (\" + rule.start + \")\" + (\"is greater than End date \" + rule.start),\n      events: []\n    };\n  }\n\n  if (!freq) {\n    return {\n      success: false,\n      errorMessage: \"Invalid recurrence frequency \\\"\" + freqName + \"\\\"\",\n      events: []\n    };\n  }\n\n  var events = [];\n  var positions = rule.bySetPosition;\n  var currentIdx = positions ? 0 : 1;\n  var exceptionDates = rule.exceptionDates;\n  var start = rangeStart.toTimezone(eventStart.timezone);\n  var startPeriod = start;\n  var end = rangeEnd.toTimezone(eventStart.timezone);\n  var count = rule.count;\n\n  if (rule.until && rule.until.getTime() < end.getTime()) {\n    end = rule.until.clone();\n  }\n\n  var hours = start.getHours();\n  var minutes = start.getMinutes();\n  var seconds = start.getSeconds();\n  var useEventStart = freqName === 'yearly' || freqName === 'monthly' || freqName === 'weekly';\n\n  if (start.getTime() < eventStart.getTime() || count || rule.interval > 1 || useEventStart) {\n    start = eventStart.clone();\n  } else {\n    if (!rule.byHour) {\n      hours = eventStart.getHours();\n    }\n\n    if (!rule.byMinute) {\n      minutes = eventStart.getMinutes();\n    }\n\n    if (!rule.bySecond) {\n      seconds = eventStart.getSeconds();\n    }\n\n    var startAdj = start.toUTCDate();\n    startAdj.setUTCHours(hours, minutes, seconds, eventStart.getMilliseconds());\n    start = ZonedDate.fromUTCDate(startAdj, start.timezone);\n  }\n\n  rule._startPeriod = start.clone();\n\n  if (positions) {\n    start = startPeriodByFreq(start, rule);\n    end = endPeriodByFreq(end, rule);\n    var diff = getTimeAfterMidnight(end) - getTimeAfterMidnight(start);\n\n    if (diff < 0) {\n      var endAdj = end.toUTCDate();\n      endAdj.setUTCHours(start.getHours(), start.getMinutes(), start.getSeconds(), start.getMilliseconds());\n      end = ZonedDate.fromUTCDate(endAdj, end.timezone);\n    }\n\n    rule._startPeriod = start.clone();\n    endPeriod = endPeriodByFreq(start, rule);\n  }\n\n  var startTime = getTimeAfterMidnight(start);\n  rule._startTime = new Date(startTime);\n  var next = start.toUTCDate();\n\n  if (freq.setup) {\n    freq.setup(rule, eventStart, next);\n    start = ZonedDate.fromUTCDate(next, start.timezone);\n  }\n\n  next = start.toUTCDate();\n  freq.limit(next, end.toUTCDate(), rule);\n  start = ZonedDate.fromUTCDate(next, start.timezone);\n\n  while (start <= end) {\n    var endDate = start.addTime(eventDuration);\n    var inPeriod = start >= startPeriod || endDate > startPeriod;\n\n    if (inPeriod && !isException(exceptionDates, start) || positions) {\n      events.push({\n        start: normalizeDST(start),\n        end: normalizeDST(endDate)\n      });\n\n      if (freqName === 'hourly' || freqName === 'minutely' || freqName === 'secondly') {\n        // Use the DST-adjusted time to maintain duration between occurrences\n        startTime = getTimeAfterMidnight(normalizeDST(start));\n        rule._startTime = new Date(startTime);\n      }\n    }\n\n    if (positions) {\n      next = start.toUTCDate();\n      freq.next(next, rule);\n      freq.limit(next, end.toUTCDate(), rule);\n      start = ZonedDate.fromUTCDate(next, start.timezone);\n\n      if (start > endPeriod) {\n        var periodEvents = eventsByPosition(events.slice(currentIdx), eventStart, positions);\n        periodEvents = removeExceptionDates(periodEvents, exceptionDates);\n        events = events.slice(0, currentIdx).concat(periodEvents);\n        endPeriod = endPeriodByFreq(start, rule);\n        currentIdx = events.length;\n      }\n\n      if (count && count === currentIdx) {\n        break;\n      }\n    } else {\n      if (count && count === currentIdx) {\n        break;\n      }\n\n      currentIdx += 1;\n      next = start.toUTCDate();\n      freq.next(next, rule);\n      freq.limit(next, end.toUTCDate(), rule);\n      start = ZonedDate.fromUTCDate(next, start.timezone);\n    }\n  }\n\n  return {\n    success: true,\n    errorMessage: '',\n    events: events\n  };\n}","map":null,"metadata":{},"sourceType":"module"}