{"ast":null,"code":"import * as React from 'react';\nimport { getRect, setRect, last } from '../../common/utils';\nimport { BORDER_WIDTH } from '../../../constants';\nimport { useRtl } from '../../../hooks';\nimport { first } from '../../../utils';\n/** @hidden */\n\nexport var useMonthFragmentPosition = function (ref, props) {\n  var _a = React.useState(true),\n      fit = _a[0],\n      setFit = _a[1];\n\n  var _b = React.useState(false),\n      show = _b[0],\n      setShow = _b[1];\n\n  var rtl = useRtl();\n\n  var reflow = function () {\n    var element = ref.current;\n\n    if (props.slots.length === 0) {\n      setFit(false);\n      return;\n    }\n\n    var slot = !rtl ? first(props.slots) : last(props.slots);\n\n    if (!slot.ref.current) {\n      return;\n    }\n\n    var ranges = calculateRanges(props.slots);\n    var widths = calculateWidths(props.slots, ranges);\n    var rect = getRect(slot.ref.current.element);\n    var order = calculateOrder(props);\n\n    if (order > 1) {\n      setFit(false);\n      return;\n    }\n\n    var ignoreSiblings = props.resizeHint || props.dragHint;\n\n    if (ignoreSiblings) {\n      order = 0;\n    }\n\n    setRect(element, {\n      left: rect.left + BORDER_WIDTH,\n      top: (ignoreSiblings ? 0 : 30) + rect.top + order * (25 + BORDER_WIDTH),\n      width: widths[0] - BORDER_WIDTH,\n      height: ignoreSiblings ? rect.height : 25\n    });\n    setFit(true);\n    setShow(true);\n  };\n\n  var handleResize = function () {\n    if (!window) {\n      return;\n    }\n\n    window.addEventListener('resize', reflow);\n    return function () {\n      return window.removeEventListener('resize', reflow);\n    };\n  };\n\n  React.useEffect(handleResize, []);\n  React.useEffect(reflow);\n  return {\n    fit: fit,\n    show: show\n  };\n};\n\nvar calculateOrder = function (props) {\n  var order = 0;\n  props.slots.forEach(function (slot) {\n    slot.items.forEach(function (item, id) {\n      if (!item.ref.current) {\n        return order;\n      }\n\n      if (id > order && item.ref.current.props.id === props.id && item.ref.current.props.occurrenceId === props.occurrenceId // && item.ref.current.props.groupIndex === props.groupIndex\n      ) {\n          order = id;\n        }\n    });\n  });\n  return order;\n};\n\nvar calculateWidths = function (slots, ranges) {\n  var result = ranges.map(function (range) {\n    var slotsInRange = slots.filter(function (slot) {\n      return slot.rangeIndex === range;\n    });\n    return slotsInRange.reduce(function (acc, slot) {\n      if (!slot.ref.current) {\n        return acc;\n      }\n\n      return acc + getRect(slot.ref.current.element).width;\n    }, 0);\n  });\n  return result;\n};\n\nvar calculateRanges = function (slots) {\n  var result = [];\n  slots.forEach(function (slot) {\n    if (result.find(function (current) {\n      return current === slot.rangeIndex;\n    }) === undefined) {\n      result.push(slot.rangeIndex);\n    }\n  });\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}