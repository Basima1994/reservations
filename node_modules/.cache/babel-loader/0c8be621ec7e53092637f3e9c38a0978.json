{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { useLocalization, useInternationalization } from '@progress/kendo-react-intl';\nimport { messages, recurrenceEditorRepeat, recurrenceEditorEndLabel, recurrenceEditorEndAfter, recurrenceEditorEndNever, recurrenceEditorEndOccurrence, recurrenceEditorEndOn, recurrenceEditorWeeklyRepeatOn, recurrenceEditorYearlyRepeatOn, recurrenceEditorMonthlyRepeatOn, recurrenceEditorMonthlyDay, recurrenceEditorYearlyOf } from '../../messages';\nimport { isPresent, capitalize } from '../../utils';\nimport { serializeRule } from '@progress/kendo-recurrence';\nimport { ZonedDate } from '@progress/kendo-date-math';\nimport { RecurrenceFrequencyEditor } from './RecurrenceFrequencyEditor';\nimport { RecurrenceIntervalEditor } from './RecurrenceIntervalEditor';\nimport { RecurrenceEndEditor } from './RecurrenceEndEditor';\nimport { RecurrenceRepeatOnWeekEditor } from './RecurrenceRepeatOnWeekEditor';\nimport { RecurrenceRepeatOnMonthYearEditor } from './RecurrenceRepeatOnMonthYearEditor';\nimport { parseRRule, getFrequencies, getFrequency, getUntil, getMonths, getWeekDays, getExtendedWeekDays, getOffsetPositions, getEndRule, getMonthDay, getRepeatOnRule, weekDayRuleFromString } from './common';\n/** @hidden */\n\nexport var SchedulerRecurrenceEditor = function (props) {\n  var start = props.start,\n      timezone = props.timezone,\n      onFocus = props.onFocus,\n      onBlur = props.onBlur,\n      onChange = props.onChange;\n  var intlService = useInternationalization();\n  var localizationService = useLocalization();\n\n  var localizeMessage = function (baseMassage, removePrepend) {\n    var message = removePrepend ? baseMassage : 'scheduler.recurrenceEditor' + baseMassage;\n    return localizationService.toLanguageString(message, messages[message]);\n  };\n\n  var rrule = React.useMemo(function () {\n    return parseRRule(props.value);\n  }, [props.value]);\n  var frequencies = React.useMemo(function () {\n    return getFrequencies(localizeMessage);\n  }, []);\n  var frequency = React.useMemo(function () {\n    return getFrequency(rrule);\n  }, [rrule]);\n  var until = React.useMemo(function () {\n    return getUntil(rrule);\n  }, [rrule.until]);\n  var months = React.useMemo(function () {\n    return getMonths(intlService);\n  }, []);\n  var weekDays = React.useMemo(function () {\n    return getWeekDays(intlService);\n  }, []);\n  var extendedWeekDays = React.useMemo(function () {\n    return getExtendedWeekDays(intlService, localizeMessage);\n  }, []);\n  var offsetPositions = React.useMemo(function () {\n    return getOffsetPositions(localizeMessage);\n  }, []);\n  var endRule = getEndRule(rrule);\n  var monthDay = getMonthDay(rrule, start);\n  var repeatOnRule = React.useMemo(function () {\n    return getRepeatOnRule(rrule);\n  }, [rrule.byWeekDay, rrule.byMonthDay]);\n  var onChangeHandler = React.useCallback(function (newRrule) {\n    if (newRrule.freq === 'never') {\n      onChange(null);\n    } else {\n      if (newRrule.weekStart === undefined) {\n        newRrule.weekStart = intlService.firstDay();\n      }\n\n      onChange(serializeRule(newRrule, timezone));\n    }\n  }, [onChange, timezone]);\n  var onFrequencyChange = React.useCallback(function (newFreq) {\n    var newRrule = {};\n    newRrule.freq = newFreq;\n    newRrule.interval = 1;\n\n    if (newFreq === 'weekly') {\n      newRrule.byWeekDay = [{\n        day: start.getDay(),\n        offset: 0\n      }];\n    }\n\n    if (newFreq === 'monthly' || newFreq === 'yearly') {\n      newRrule.byMonthDay = [start.getDate()];\n    }\n\n    if (newFreq === 'yearly') {\n      newRrule.byMonth = [start.getMonth() + 1];\n    }\n\n    onChangeHandler(newRrule);\n  }, [onChangeHandler, start]);\n  var onIntervalChange = React.useCallback(function (e) {\n    onChangeHandler(Object.assign({}, rrule, {\n      interval: e.value\n    }));\n  }, [onChangeHandler, rrule]);\n  var onCountChange = React.useCallback(function (newCount) {\n    onChangeHandler(Object.assign({}, rrule, {\n      count: newCount\n    }));\n  }, [onChangeHandler, rrule]);\n  var onUntilChange = React.useCallback(function (newUntil) {\n    onChangeHandler(Object.assign({}, rrule, {\n      until: ZonedDate.fromLocalDate(newUntil, timezone)\n    }));\n  }, [onChangeHandler, rrule, timezone]);\n  var onWeekDaysChange = React.useCallback(function (dayIndex, selected) {\n    var isAdd = selected === 'false';\n    var parsedDayIndex = parseInt(dayIndex, 10);\n    var newWeekDays = (rrule.byWeekDay || []).map(function (day) {\n      return __assign({}, day);\n    });\n\n    if (isAdd) {\n      newWeekDays.push({\n        offset: 0,\n        day: parsedDayIndex\n      });\n    } else {\n      var indexToRemove = newWeekDays.findIndex(function (weekDay) {\n        return weekDay.day === parsedDayIndex;\n      });\n\n      if (indexToRemove > -1) {\n        newWeekDays.splice(indexToRemove, 1);\n      }\n    }\n\n    onChangeHandler(Object.assign({}, rrule, {\n      byWeekDay: newWeekDays\n    }));\n  }, [onChangeHandler, rrule]);\n  var onWeekDayChange = React.useCallback(function (weekDay, offset) {\n    var newRrule = Object.assign({}, rrule);\n\n    if (typeof weekDay === 'string') {\n      /* day, weekday or weekend */\n      newRrule.byWeekDay = weekDayRuleFromString(weekDay);\n      newRrule.bySetPosition = [offset];\n    } else {\n      /* specific weekday */\n      newRrule.byWeekDay = [{\n        day: weekDay,\n        offset: offset\n      }];\n    }\n\n    onChangeHandler(newRrule);\n  }, [onChangeHandler, rrule]);\n  var onMonthDaysChange = React.useCallback(function (newMonthDays) {\n    onChangeHandler(Object.assign({}, rrule, {\n      byMonthDay: newMonthDays\n    }));\n  }, [onChangeHandler, rrule]);\n  var onMonthsChange = React.useCallback(function (newMonths) {\n    onChangeHandler(Object.assign({}, rrule, {\n      byMonth: newMonths\n    }));\n  }, [onChangeHandler, rrule]);\n  var onEndRuleChange = React.useCallback(function (event) {\n    var newRrule = Object.assign({}, rrule);\n\n    if (event.value === 'count') {\n      newRrule.until = undefined;\n      newRrule.count = event.count;\n    } else if (event.value === 'until') {\n      newRrule.until = ZonedDate.fromLocalDate(event.until, timezone);\n      newRrule.count = undefined;\n    } else {\n      /* never */\n      newRrule.until = undefined;\n      newRrule.count = undefined;\n    }\n\n    onChangeHandler(newRrule);\n  }, [onChangeHandler, rrule, timezone]);\n  var onRepeatOnRuleChange = React.useCallback(function (newRepeatOnRule, weekDay, offset) {\n    var newRrule = Object.assign({}, rrule);\n\n    if (newRepeatOnRule === 'monthday') {\n      newRrule.byWeekDay = undefined;\n      newRrule.bySetPosition = undefined;\n      newRrule.byMonthDay = [monthDay];\n    } else if (newRepeatOnRule === 'weekday') {\n      // weekDays\n      newRrule.byMonthDay = undefined;\n\n      if (typeof weekDay === 'string') {\n        /* day, weekday or weekend */\n        newRrule.bySetPosition = [offset];\n        newRrule.byWeekDay = weekDayRuleFromString(weekDay);\n      } else {\n        /* specific weekday */\n        newRrule.byWeekDay = [{\n          day: weekDay,\n          offset: offset\n        }];\n      }\n    }\n\n    onChangeHandler(newRrule);\n  }, [onChangeHandler, rrule, monthDay]);\n  var onOffsetPositionChange = React.useCallback(function (offset) {\n    var newRrule = Object.assign({}, rrule);\n\n    if (isPresent(newRrule.byWeekDay)) {\n      var weekDaysCount = newRrule.byWeekDay.length;\n\n      switch (weekDaysCount) {\n        case 7:\n        case 5:\n        case 2:\n          newRrule.bySetPosition = [offset];\n          break;\n\n        case 1:\n          newRrule.byWeekDay[0].offset = offset;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    onChangeHandler(newRrule);\n  }, [onChangeHandler, rrule]);\n  var onFocusHandler = React.useCallback(function () {\n    onFocus();\n  }, [onFocus]);\n  var onBlurHandler = React.useCallback(function () {\n    onBlur();\n  }, [onBlur]);\n  return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n    onFocus: onFocusHandler,\n    onBlur: onBlurHandler\n  }, React.createElement(RecurrenceFrequencyEditor, {\n    titleClassName: 'k-edit-label',\n    editorClassName: 'k-edit-field',\n    title: localizeMessage(recurrenceEditorRepeat, true),\n    frequency: frequency,\n    frequencies: frequencies,\n    onFrequencyChange: onFrequencyChange\n  })), frequency !== 'never' && React.createElement(\"div\", {\n    onFocus: onFocusHandler,\n    onBlur: onBlurHandler\n  }, React.createElement(RecurrenceIntervalEditor, {\n    titleClassName: 'k-edit-label',\n    editorClassName: 'k-edit-field',\n    title: localizeMessage(capitalize(frequency) + 'RepeatEvery'),\n    frequencyText: localizeMessage(capitalize(frequency) + 'Interval'),\n    interval: rrule.interval,\n    onIntervalChange: onIntervalChange\n  })), frequency === 'weekly' && React.createElement(\"div\", {\n    onFocus: onFocusHandler,\n    onBlur: onBlurHandler\n  }, React.createElement(RecurrenceRepeatOnWeekEditor, {\n    titleClassName: 'k-edit-label',\n    editorClassName: 'k-edit-field',\n    title: localizeMessage(recurrenceEditorWeeklyRepeatOn, true),\n    weekDays: weekDays,\n    byWeekDay: rrule.byWeekDay,\n    onWeekDaysChange: onWeekDaysChange\n  })), (frequency === 'monthly' || frequency === 'yearly') && React.createElement(\"div\", {\n    onFocus: onFocusHandler,\n    onBlur: onBlurHandler\n  }, React.createElement(RecurrenceRepeatOnMonthYearEditor, {\n    titleClassName: 'k-edit-label',\n    editorClassName: 'k-edit-field',\n    titleMonthly: localizeMessage(recurrenceEditorMonthlyRepeatOn, true),\n    titleYearly: localizeMessage(recurrenceEditorYearlyRepeatOn, true),\n    monthlyDayTitle: localizeMessage(recurrenceEditorMonthlyDay, true),\n    yearlyOf: localizeMessage(recurrenceEditorYearlyOf, true),\n    monthDay: monthDay,\n    frequency: frequency,\n    repeatOnRule: repeatOnRule,\n    start: start,\n    rrule: rrule,\n    months: months,\n    extendedWeekDays: extendedWeekDays,\n    offsetPositions: offsetPositions,\n    onRepeatOnRuleChange: onRepeatOnRuleChange,\n    onMonthDaysChange: onMonthDaysChange,\n    onMonthsChange: onMonthsChange,\n    onOffsetPositionChange: onOffsetPositionChange,\n    onWeekDayChange: onWeekDayChange\n  })), frequency !== 'never' && React.createElement(\"div\", {\n    onFocus: onFocusHandler,\n    onBlur: onBlurHandler\n  }, React.createElement(RecurrenceEndEditor, {\n    title: localizeMessage(recurrenceEditorEndLabel, true),\n    endAfter: localizeMessage(recurrenceEditorEndAfter, true),\n    endNever: localizeMessage(recurrenceEditorEndNever, true),\n    endOccurrence: localizeMessage(recurrenceEditorEndOccurrence, true),\n    endOn: localizeMessage(recurrenceEditorEndOn, true),\n    titleClassName: 'k-edit-label',\n    editorClassName: 'k-edit-field',\n    count: rrule.count,\n    endRule: endRule,\n    start: start,\n    until: until,\n    timezone: timezone,\n    onCountChange: onCountChange,\n    onUntilChange: onUntilChange,\n    onEndRuleChange: onEndRuleChange\n  })));\n};\nSchedulerRecurrenceEditor.defaultProps = {\n  value: ''\n};\nSchedulerRecurrenceEditor.displayName = 'KendoReactSchedulerRepeatEditor';","map":null,"metadata":{},"sourceType":"module"}