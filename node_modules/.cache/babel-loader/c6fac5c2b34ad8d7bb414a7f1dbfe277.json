{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { generateWeekSlots } from './weekService';\nimport { intersects, toUTCDate } from '../utils';\nimport { generateDaySlots } from './dayService';\nimport { orderBy } from '@progress/kendo-data-query';\nimport { EMPTY_RESOURCE } from '../constants';\nimport { expandResources, toGroupResources } from '../views/common/utils';\nimport { ZonedDate } from '@progress/kendo-date-math';\n/** @hidden */\n\nexport var toMonthRanges = generateWeekSlots;\n/** @hidden */\n\nexport var toMonthSlots = function (group, resources, ranges, timezone, workWeekStart, workWeekEnd) {\n  var slots = [];\n  var groupResources = toGroupResources(group, resources);\n  var expandedResources = expandResources(groupResources || [], (groupResources || []).length - 1);\n  var hasGroups = expandedResources.length > 0;\n  (hasGroups ? expandedResources : EMPTY_RESOURCE).forEach(function (_, groupIndex) {\n    return ranges.forEach(function (range, rangeIndex) {\n      generateDaySlots(range.start, range.end, timezone, {\n        workWeekStart: workWeekStart,\n        workWeekEnd: workWeekEnd\n      }).forEach(function (slot) {\n        slots.push(__assign({}, slot, {\n          groupIndex: hasGroups ? groupIndex : undefined,\n          rangeIndex: rangeIndex\n        }));\n      });\n    });\n  });\n  return slots;\n};\n/** @hidden */\n\nexport var toMonthItems = function (_a) {\n  var rangeStart = _a.rangeStart,\n      rangeEnd = _a.rangeEnd,\n      timezone = _a.timezone,\n      ranges = _a.ranges,\n      data = _a.data;\n  var items = [];\n  var sorted = orderBy(data, [{\n    field: 'start',\n    dir: 'asc'\n  }, {\n    field: 'end',\n    dir: 'desc'\n  }, {\n    field: 'isAllDay',\n    dir: 'desc'\n  }]);\n\n  for (var index = 0; index < sorted.length; index++) {\n    var item = toMonthItem(sorted[index], {\n      timezone: timezone,\n      ranges: ranges,\n      rangeStart: rangeStart,\n      rangeEnd: rangeEnd\n    });\n\n    if (item) {\n      items.push(item);\n    }\n  }\n\n  return items;\n};\n/** @hidden */\n\nexport var toMonthItem = function (item, _a) {\n  var timezone = _a.timezone,\n      ranges = _a.ranges,\n      rangeStart = _a.rangeStart,\n      rangeEnd = _a.rangeEnd;\n  var viewRangeStart = toUTCDate(rangeStart);\n  var viewRangeEnd = toUTCDate(rangeEnd);\n  var isRecurring = Boolean(item.recurrenceRule);\n  var isException = item.recurrenceId !== undefined && item.recurrenceId !== null && !isRecurring;\n  var isAllDay = Boolean(item.isAllDay); // || (!inEdit && isMultiDay(eventItem.dataItem));\n\n  if (intersects(item.start, item.end, viewRangeStart, viewRangeEnd)) {\n    var ref = React.createRef();\n    var zonedStart = ZonedDate.fromLocalDate(item.start, timezone);\n    var zonedEnd = ZonedDate.fromLocalDate(item.end, timezone);\n\n    var viewItem = __assign({}, item, {\n      ref: ref,\n      order: null,\n      slots: [],\n      ranges: ranges.filter(function (range) {\n        return intersects(item.start, item.end, range.start, range.end);\n      }),\n      zonedStart: zonedStart,\n      zonedEnd: zonedEnd,\n      isAllDay: isAllDay,\n      isException: isException,\n      isRecurring: isRecurring,\n      isEdge: false,\n      head: item.end > rangeEnd,\n      tail: item.start < rangeStart\n    });\n\n    return viewItem;\n  }\n\n  return null;\n};","map":null,"metadata":{},"sourceType":"module"}