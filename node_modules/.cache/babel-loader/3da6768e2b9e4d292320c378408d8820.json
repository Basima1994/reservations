{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-scheduler-core\n * Generated: 2019-12-05\n * Version: 2.3.1\n * License: https://js.devexpress.com/Licensing\n */\nimport moment from 'moment';\nimport { RRuleSet, RRule } from 'rrule';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n\nvar VERTICAL_TYPE = 'vertical';\nvar HORIZONTAL_TYPE = 'horizontal';\nvar SCROLL_OFFSET = 50;\nvar SCROLL_SPEED_PX = 30;\nvar SECONDS = 'seconds';\nvar MINUTES = 'minutes';\nvar HOURS = 'hours';\nvar RESIZE_TOP = 'resize-start';\nvar RESIZE_BOTTOM = 'resize-end';\nvar POSITION_START = 'start';\nvar POSITION_END = 'end';\nvar AUTO_HEIGHT = 'auto';\nvar DAY_OPTIONS = {\n  day: 'numeric'\n};\nvar WEEK_DAY_OPTIONS = {\n  weekday: 'short'\n};\nvar SHORT_MONTH_OPTIONS = {\n  month: 'short'\n};\nvar HOUR_MINUTE_OPTIONS = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\nvar MONTH_YEAR_OPTIONS = {\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'short'\n};\nvar SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  month: 'short',\n  year: 'numeric'\n};\nvar SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  month: 'short',\n  year: '2-digit'\n};\nvar DAY_LONG_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: '2-digit'\n};\nvar LONG_WEEK_DAY_OPTIONS = {\n  weekday: 'long'\n};\nvar LONG_MONTH_OPTIONS = {\n  month: 'long'\n};\nvar DAY_LONG_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'long'\n};\nvar EMPTY_OPTIONS = {};\nvar RECURRENCE_EDIT_SCOPE = {\n  ALL: 'all',\n  CURRENT_AND_FOLLOWING: 'currentAndFollowing',\n  CURRENT: 'current'\n};\nvar TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';\nvar TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';\nvar WEEKDAY_INTERVAL = 'weekdayInterval';\n\nvar computed = function computed(getters, viewName, baseComputed, defaultValue) {\n  if (getters.currentView.name !== viewName && !!defaultValue) {\n    return defaultValue;\n  }\n\n  return baseComputed(getters, viewName);\n};\n\nvar appointmentHeightType = function appointmentHeightType(appointment, cellDuration) {\n  var durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;\n  if (durationRatio === 1) return 'middle';\n  if (durationRatio > 1) return 'long';\n  return 'short';\n};\n\nvar toPercentage = function toPercentage(value, total) {\n  return value * 100 / total;\n};\n\nvar createExcludedInterval = function createExcludedInterval(day, start) {\n  var leftBound = moment(start.day(day));\n  return [leftBound, moment(leftBound).hour(start.hour()).endOf('day')];\n};\n\nvar excludedIntervals = function excludedIntervals(excludedDays, start) {\n  return excludedDays.map(function (day) {\n    return day === 0 ? 7 : day;\n  }).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, day, i, allDays) {\n    if (i && day === allDays[i - 1] + 1) {\n      acc[i - 1][1].day(day);\n    } else {\n      acc.push(createExcludedInterval(day, start));\n    }\n\n    return acc;\n  }, []);\n};\n\nvar byDayPredicate = function byDayPredicate(boundary, date) {\n  return boundary.isSameOrAfter(date, 'day') && !boundary.isSame(boundary.clone().startOf('day'));\n};\n\nvar inInterval = function inInterval(date, interval) {\n  return date.isBetween(interval[0], interval[1], undefined, '[]');\n};\n\nvar viewPredicate = function viewPredicate(appointment, left, right, excludedDays, removeAllDayAppointments) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  if (removeAllDayAppointments === void 0) {\n    removeAllDayAppointments = false;\n  }\n\n  var start = appointment.start,\n      end = appointment.end;\n  var isAppointmentInBoundary = end.isAfter(left) && start.isBefore(right);\n  var isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left)).find(function (interval) {\n    return inInterval(start, interval) && inInterval(end, interval);\n  });\n  var considerAllDayAppointment = removeAllDayAppointments ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay : true;\n  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;\n};\n\nvar compareByDay = function compareByDay(first, second) {\n  if (first.start.isBefore(second.start, 'day')) return -1;\n  if (first.start.isAfter(second.start, 'day')) return 1;\n  return 0;\n};\n\nvar compareByAllDay = function compareByAllDay(first, second) {\n  if (first.allDay && !second.allDay) return -1;\n  if (!first.allDay && second.allDay) return 1;\n  return 0;\n};\n\nvar compareByTime = function compareByTime(first, second) {\n  if (first.start.isBefore(second.start)) return -1;\n  if (first.start.isAfter(second.start)) return 1;\n  if (first.end.isBefore(second.end)) return 1;\n  if (first.end.isAfter(second.end)) return -1;\n  return 0;\n};\n\nvar sortAppointments = function sortAppointments(appointments) {\n  return appointments.slice().sort(function (a, b) {\n    return compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b);\n  });\n};\n\nvar findOverlappedAppointments = function findOverlappedAppointments(sortedAppointments, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  var appointments = sortedAppointments.slice();\n  var groups = [];\n  var totalIndex = 0;\n\n  while (totalIndex < appointments.length) {\n    groups.push([]);\n    var current = appointments[totalIndex];\n    var currentGroup = groups[groups.length - 1];\n    var next = appointments[totalIndex + 1];\n    var maxBoundary = current.end;\n    currentGroup.push(current);\n    totalIndex += 1;\n\n    while (next && (maxBoundary.isAfter(next.start) || byDay && byDayPredicate(maxBoundary, next.start))) {\n      currentGroup.push(next);\n      if (maxBoundary.isBefore(next.end)) maxBoundary = next.end;\n      totalIndex += 1;\n      next = appointments[totalIndex];\n    }\n  }\n\n  return groups;\n};\n\nvar isMidnight = function isMidnight(date) {\n  return date.isSame(date.clone().startOf('day'));\n};\n\nvar maxBoundaryPredicate = function maxBoundaryPredicate(maxBoundary, startDate) {\n  return maxBoundary.isBefore(startDate, 'day') || isMidnight(maxBoundary) && maxBoundary.isSame(startDate, 'day');\n};\n\nvar adjustAppointments = function adjustAppointments(groups, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  return groups.map(function (items) {\n    var offset = 0;\n    var reduceValue = 1;\n    var appointments = items.slice();\n    var groupLength = appointments.length;\n\n    for (var startIndex = 0; startIndex < groupLength; startIndex += 1) {\n      var appointment = appointments[startIndex];\n\n      if (appointment.offset === undefined) {\n        var maxBoundary = appointment.end;\n        appointment.offset = offset;\n\n        for (var index = startIndex + 1; index < groupLength; index += 1) {\n          if (appointments[index].offset === undefined) {\n            if (!byDay && maxBoundary.isSameOrBefore(appointments[index].start) || byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start)) {\n              maxBoundary = appointments[index].end;\n              appointments[index].offset = offset;\n            }\n          }\n        }\n\n        offset += 1;\n        if (reduceValue < offset) reduceValue = offset;\n      }\n    }\n\n    return {\n      items: appointments,\n      reduceValue: reduceValue\n    };\n  });\n};\n\nvar calculateFirstDateOfWeek = function calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var currentLocale = moment.locale();\n  moment.updateLocale('tmp-locale', {\n    week: {\n      dow: firstDayOfWeek,\n      doy: 1\n    }\n  });\n  var firstDateOfWeek = moment(currentDate).startOf('week');\n\n  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {\n    excludedDays.slice().sort().forEach(function (day) {\n      if (day === firstDateOfWeek.day()) {\n        firstDateOfWeek.add(1, 'days');\n      }\n    });\n  }\n\n  moment.locale(currentLocale);\n  return firstDateOfWeek.toDate();\n};\n\nvar unwrapGroups = function unwrapGroups(groups) {\n  return groups.reduce(function (acc, _a) {\n    var items = _a.items,\n        reduceValue = _a.reduceValue;\n    acc.push.apply(acc, __spread(items.map(function (appointment) {\n      return {\n        start: appointment.start,\n        end: appointment.end,\n        dataItem: appointment.dataItem,\n        offset: appointment.offset,\n        reduceValue: reduceValue,\n        fromPrev: moment(appointment.start).diff(appointment.dataItem.startDate, 'minutes') > 1,\n        toNext: moment(appointment.dataItem.endDate).diff(appointment.end, 'minutes') > 1\n      };\n    })));\n    return acc;\n  }, []);\n};\n\nvar getAppointmentStyle = function getAppointmentStyle(_a) {\n  var top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n  return {\n    height: height,\n    width: width + \"%\",\n    transform: \"translateY(\" + top + \"px)\",\n    msTransform: \"translateY(\" + top + \"px)\",\n    left: left + \"%\",\n    position: 'absolute'\n  };\n};\n\nvar rectCalculatorBase = function rectCalculatorBase(appointment, getRectByDates, options) {\n  return getRectByDates(appointment.start, appointment.end, options);\n};\n\nvar horizontalRectCalculator = function horizontalRectCalculator(appointment, _a) {\n  var rectByDates = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      cellElementsMeta = _b.cellElementsMeta,\n      viewCellsData = _b.viewCellsData;\n\n  var _c = rectCalculatorBase(appointment, rectByDates, {\n    multiline: multiline,\n    cellElementsMeta: cellElementsMeta,\n    viewCellsData: viewCellsData\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  return {\n    top: top + height / appointment.reduceValue * appointment.offset,\n    height: height / appointment.reduceValue,\n    left: toPercentage(left, parentWidth),\n    width: toPercentage(width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    type: HORIZONTAL_TYPE\n  };\n};\n\nvar verticalRectCalculator = function verticalRectCalculator(appointment, _a) {\n  var rectByDates = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      viewCellsData = _b.viewCellsData,\n      cellDuration = _b.cellDuration,\n      cellElementsMeta = _b.cellElementsMeta,\n      excludedDays = _b.excludedDays;\n\n  var _c = rectCalculatorBase(appointment, rectByDates, {\n    multiline: multiline,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    excludedDays: excludedDays,\n    cellElementsMeta: cellElementsMeta\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  var widthInPx = width / appointment.reduceValue;\n  return {\n    top: top,\n    height: height,\n    left: toPercentage(left + widthInPx * appointment.offset, parentWidth),\n    width: toPercentage(widthInPx, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE\n  };\n};\n\nvar calculateRectByDateIntervals = function calculateRectByDateIntervals(type, intervals, rectByDates, rectByDatesMeta) {\n  var growDirection = type.growDirection,\n      multiline = type.multiline;\n  var isHorizontal = growDirection === HORIZONTAL_TYPE;\n  var sorted = sortAppointments(intervals);\n  var grouped = findOverlappedAppointments(sorted, isHorizontal);\n  var rectCalculator = isHorizontal ? horizontalRectCalculator : verticalRectCalculator;\n  return unwrapGroups(adjustAppointments(grouped, isHorizontal)).map(function (appointment) {\n    return rectCalculator(appointment, {\n      rectByDates: rectByDates,\n      multiline: multiline,\n      rectByDatesMeta: rectByDatesMeta\n    });\n  });\n};\n\nvar expandRecurrenceAppointment = function expandRecurrenceAppointment(appointment, leftBound, rightBound) {\n  var rightBoundUTC = moment(getUTCDate(rightBound)).toDate();\n  var leftBoundUTC = moment(getUTCDate(leftBound)).toDate();\n  var appointmentStartDate = moment(appointment.start).toDate();\n\n  var options = _assign(_assign({}, RRule.parseString(appointment.rRule)), {\n    dtstart: moment(getUTCDate(appointmentStartDate)).toDate()\n  });\n\n  var correctedOptions = options.until ? _assign(_assign({}, options), {\n    until: moment(getUTCDate(options.until)).toDate()\n  }) : options;\n  var rruleSet = getRRuleSetWithExDates(appointment.exDate);\n  rruleSet.rrule(new RRule(correctedOptions)); // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates\n  // we have to format the dates we get from RRuleSet to get local dates\n\n  var datesInBoundaries = rruleSet.between(leftBoundUTC, rightBoundUTC, true).map(formatDateToString);\n  if (datesInBoundaries.length === 0) return [];\n  var appointmentDuration = moment(appointment.end).diff(appointment.start, 'minutes');\n  return datesInBoundaries.map(function (startDate, index) {\n    return _assign(_assign({}, appointment), {\n      dataItem: _assign(_assign({}, appointment.dataItem), {\n        startDate: moment(startDate).toDate(),\n        endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(),\n        parentData: appointment.dataItem\n      }),\n      start: moment(startDate),\n      end: moment(startDate).add(appointmentDuration, 'minutes')\n    });\n  });\n};\n\nvar filterByViewBoundaries = function filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, removeAllDay) {\n  var appointments = [appointment];\n\n  if (appointment.rRule) {\n    appointments = expandRecurrenceAppointment(appointment, leftBound, rightBound);\n  }\n\n  return appointments.filter(function (appt) {\n    return viewPredicate(appt, leftBound, rightBound, excludedDays, removeAllDay);\n  });\n};\n\nvar getUTCDate = function getUTCDate(date) {\n  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());\n};\n\nvar getRRuleSetWithExDates = function getRRuleSetWithExDates(exDate) {\n  var rruleSet = new RRuleSet();\n\n  if (exDate) {\n    exDate.split(',').map(function (date) {\n      var currentExDate = moment(date).toDate();\n      rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());\n    });\n  }\n\n  return rruleSet;\n};\n\nvar formatDateToString = function formatDateToString(date) {\n  return moment.utc(date).format('YYYY-MM-DDTHH:mm');\n};\n\nvar MONTH_TYPE = 'month';\n\nvar getViewType = function getViewType(currentViewType) {\n  if (currentViewType === MONTH_TYPE) return HORIZONTAL_TYPE;\n  return VERTICAL_TYPE;\n};\n\nvar isMidnight$1 = function isMidnight$1(date) {\n  var momentDate = moment(date);\n  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;\n};\n\nvar calculateTextByDays = function calculateTextByDays(startViewDate, endViewDate, formatDate, additionalOptions) {\n  var momentStartViewDate = moment(startViewDate);\n  var momentEndViewDate = moment(endViewDate);\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {\n    return formatDate(momentStartViewDate.toDate(), _assign(_assign({}, DAY_LONG_MONTH_LONG_YEAR_OPTIONS), additionalOptions));\n  }\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {\n    if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {\n      return formatDate(momentStartViewDate.toDate(), DAY_OPTIONS) + \"-\" + formatDate(momentEndViewDate.toDate(), DAY_OPTIONS) + \" \" + formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS);\n    }\n\n    return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar calculateTextByMonths = function calculateTextByMonths(currentDate, intervalCount, formatDate) {\n  var momentCurrentDate = moment(currentDate);\n\n  if (intervalCount === 1) {\n    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);\n  }\n\n  var lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');\n\n  if (momentCurrentDate.isSame(lastMonth, 'year')) {\n    return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS) + \"-\" + formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar viewBoundText = function viewBoundText(startViewDate, endViewDate, type, currentDate, intervalCount, formatDate) {\n  return type !== 'month' ? calculateTextByDays(startViewDate, endViewDate, formatDate, type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS) : calculateTextByMonths(currentDate, intervalCount, formatDate);\n};\n\nvar subtractSecond = function subtractSecond(date) {\n  return moment(date).subtract(1, 'second').toDate();\n};\n\nvar dayScale = function dayScale(currentDate, firstDayOfWeek, dayCount, excluded) {\n  if (excluded === void 0) {\n    excluded = [];\n  }\n\n  var result = [];\n  var date = firstDayOfWeek !== undefined ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded)) : moment(currentDate);\n\n  for (var index = 0; index < dayCount; index += 1) {\n    if (excluded.findIndex(function (item) {\n      return item === date.day();\n    }) === -1) {\n      result.push(date.toDate());\n    }\n\n    date.add(1, 'days');\n  }\n\n  return result;\n};\n\nvar timeScale = function timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays) {\n  var result = [];\n  var startDateOfView = firstDayOfWeek !== undefined ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) : currentDate;\n  var left = moment(startDateOfView).startOf('day').add(startDayHour, 'hour');\n  var right = moment(startDateOfView).startOf('day').add(endDayHour, 'hour');\n\n  while (left.isBefore(right)) {\n    var startDate = left.toDate();\n    left.add(cellDuration, 'minutes');\n    result.push({\n      start: startDate,\n      end: left.toDate()\n    });\n  }\n\n  var timeScaleLastIndex = result.length - 1;\n\n  if (isMidnight$1(result[timeScaleLastIndex].end)) {\n    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end);\n  }\n\n  return result;\n};\n\nvar availableViews = function availableViews(views, viewName, viewDisplayName) {\n  if (!views) return [{\n    name: viewName,\n    displayName: viewDisplayName\n  }];\n\n  if (views.findIndex(function (view) {\n    return viewName === view.name;\n  }) === -1) {\n    var nextViews = views.slice();\n    nextViews.push({\n      name: viewName,\n      displayName: viewDisplayName\n    });\n    return nextViews;\n  }\n\n  return views;\n};\n\nvar viewCellsData = function viewCellsData(currentDate, firstDayOfWeek, dayCount, excludedDays, startDayHour, endDayHour, cellDuration, currTime) {\n  var days = dayScale(currentDate, firstDayOfWeek, dayCount, excludedDays);\n  var times = timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays);\n  var currentTime = moment(currTime);\n  return times.reduce(function (cellsAcc, time) {\n    var start = moment(time.start);\n    var end = moment(time.end);\n    var rowCells = days.reduce(function (rowAcc, day) {\n      var startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();\n      var endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();\n      var today = currentTime.isSame(startDate, 'day');\n      rowAcc.push({\n        startDate: startDate,\n        endDate: endDate,\n        today: today\n      });\n      return rowAcc;\n    }, []);\n    cellsAcc.push(rowCells);\n    return cellsAcc;\n  }, []);\n};\n\nvar allDayCells = function allDayCells(viewCells) {\n  return viewCells[0].map(function (cell) {\n    return {\n      startDate: moment(cell.startDate).startOf('day').toDate(),\n      endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate()\n    };\n  });\n};\n\nvar startViewDate = function startViewDate(viewCells) {\n  return moment(viewCells[0][0].startDate).toDate();\n};\n\nvar endViewDate = function endViewDate(viewCells) {\n  var lastRowIndex = viewCells.length - 1;\n  var lastCellIndex = viewCells[lastRowIndex].length - 1;\n  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate);\n};\n\nvar sliceAppointmentByDay = function sliceAppointmentByDay(appointment, cellDuration) {\n  var start = appointment.start,\n      end = appointment.end,\n      dataItem = appointment.dataItem;\n  if (start.isSame(end, 'day')) return [appointment];\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;\n  var isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;\n  return [isShortOnFirstDay ? {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day'),\n    dataItem: dataItem\n  } : {\n    start: start,\n    end: start.clone().endOf('day'),\n    dataItem: dataItem\n  }, isShortOnSecondDay ? {\n    start: end.clone().startOf('day'),\n    end: end.clone().startOf('day').add(minDuration, 'minutes'),\n    dataItem: dataItem\n  } : {\n    start: end.clone().startOf('day'),\n    end: end,\n    dataItem: dataItem\n  }];\n};\n\nvar dayBoundaryPredicate = function dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes());\n  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd)) return false;\n  if (excludedDays.findIndex(function (day) {\n    return day === moment(appointment.start).day();\n  }) !== -1) return false;\n  return appointment.end.isAfter(startDayTime) && appointment.start.isBefore(endDayTime);\n};\n\nvar reduceAppointmentByDayBounds = function reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration) {\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes()).seconds(dayStart.seconds());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes()).seconds(dayEnd.seconds());\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;\n  var isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;\n\n  if (isShortOnFirstDay) {\n    return _assign(_assign({}, appointment), {\n      start: endDayTime.clone().add(-minDuration, 'minutes'),\n      end: endDayTime\n    });\n  }\n\n  if (isShortOnSecondDay) {\n    return _assign(_assign({}, appointment), {\n      start: startDayTime,\n      end: startDayTime.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return _assign(_assign(_assign({}, appointment), appointment.start.isSameOrBefore(startDayTime) ? {\n    start: startDayTime\n  } : null), appointment.end.isSameOrAfter(endDayTime) ? {\n    end: endDayTime\n  } : null);\n};\n\nvar normalizeAppointmentDuration = function normalizeAppointmentDuration(appointment, cellDuration) {\n  var minDuration = cellDuration / 2;\n  var start = moment(appointment.start);\n  var end = moment(appointment.end);\n\n  if (end.diff(start, 'minutes') > minDuration) {\n    return _assign(_assign({}, appointment), {\n      start: start,\n      end: end\n    });\n  }\n\n  if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {\n    return _assign(_assign({}, appointment), {\n      start: start,\n      end: start.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return _assign(_assign({}, appointment), {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day')\n  });\n};\n\nvar calculateWeekDateIntervals = function calculateWeekDateIntervals(appointments, leftBound, rightBound, // startViewDate, endViewDate\nexcludedDays, cellDuration) {\n  return appointments.map(function (appointment) {\n    return normalizeAppointmentDuration(appointment, cellDuration);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByDay(appointment, cellDuration));\n  }, []).filter(function (appointment) {\n    return dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays);\n  }).map(function (appointment) {\n    return reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration);\n  });\n};\n\nvar CELL_GAP_PX = 10;\nvar CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;\nvar CELL_BOUND_VERTICAL_OFFSET_PX = 4;\n\nvar getCellByDate = function getCellByDate(viewCellsData, date, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var cellIndex = viewCellsData[0].findIndex(function (timeCell) {\n    return moment(date).isSame(timeCell.startDate, 'date');\n  });\n  var rowIndex = viewCellsData.findIndex(function (timeCell) {\n    return moment(date).isBetween(timeCell[cellIndex].startDate, timeCell[cellIndex].endDate, 'seconds', takePrev ? '(]' : '[)');\n  });\n  var totalCellIndex = rowIndex * viewCellsData[0].length + cellIndex;\n  return {\n    index: totalCellIndex,\n    startDate: viewCellsData[rowIndex][cellIndex].startDate\n  };\n};\n\nvar getCellRect = function getCellRect(date, viewCellsData, cellDuration, cellElementsMeta, takePrev) {\n  var _a = getCellByDate(viewCellsData, date, takePrev),\n      cellIndex = _a.index,\n      cellStartDate = _a.startDate;\n\n  var _b = cellElementsMeta.getCellRects[cellIndex](),\n      top = _b.top,\n      left = _b.left,\n      width = _b.width,\n      cellHeight = _b.height;\n\n  var timeOffset = moment(date).diff(cellStartDate, 'minutes');\n  var topOffset = cellHeight * (timeOffset / cellDuration);\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    topOffset: topOffset,\n    parentRect: parentRect\n  };\n};\n\nvar getVerticalRectByDates = function getVerticalRectByDates(startDate, endDate, _a) {\n  var viewCellsData = _a.viewCellsData,\n      cellDuration = _a.cellDuration,\n      cellElementsMeta = _a.cellElementsMeta;\n  var firstCellRect = getCellRect(startDate, viewCellsData, cellDuration, cellElementsMeta, false);\n  var lastCellRect = getCellRect(endDate, viewCellsData, cellDuration, cellElementsMeta, true);\n  var top = firstCellRect.top + firstCellRect.topOffset;\n  var height = lastCellRect.top + lastCellRect.topOffset - top;\n  return {\n    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    parentWidth: firstCellRect.parentRect.width,\n    height: height - CELL_BOUND_VERTICAL_OFFSET_PX\n  };\n};\n\nvar allDayPredicate = function allDayPredicate(appointment) {\n  return appointment.end.diff(appointment.start, 'hours') > 23 || !!appointment.allDay;\n};\n\nvar getAllDayCellIndexByDate = function getAllDayCellIndexByDate(viewCellsData, date, takePrev) {\n  var currentDate = moment(date);\n  var cellIndex = viewCellsData[0].findIndex(function (day) {\n    return moment(day.startDate).day() === currentDate.day();\n  });\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n\n  return cellIndex;\n};\n\nvar sliceAppointmentsByBoundaries = function sliceAppointmentsByBoundaries(appointment, left, right, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var startDate = appointment.start.clone();\n  var endDate = appointment.end.clone();\n  var nextStart = startDate.clone();\n  var nextEnd = endDate.clone();\n\n  if (startDate.isBefore(left)) {\n    nextStart = moment(left);\n    nextStart.startOf('day');\n  }\n\n  if (endDate.isAfter(right)) {\n    nextEnd = moment(right);\n    nextEnd.endOf('day');\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === startDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextStart.day();\n    }) !== -1 && nextStart.isSameOrBefore(endDate, 'day')) {\n      nextStart.add(1, 'days').startOf('day');\n    }\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === endDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextEnd.day();\n    }) !== -1 && nextStart.isSameOrAfter(startDate, 'day')) {\n      nextEnd.add(-1, 'days').endOf('day');\n    }\n  }\n\n  return [_assign(_assign({}, appointment), {\n    start: nextStart,\n    end: nextEnd\n  })];\n};\n\nvar sliceAppointmentByWeek = function sliceAppointmentByWeek(timeBounds, appointment, step) {\n  var left = timeBounds.left,\n      right = timeBounds.right;\n  var pieces = [];\n\n  var start = appointment.start,\n      end = appointment.end,\n      restFields = __rest(appointment, [\"start\", \"end\"]);\n\n  var apptStart = start;\n  var apptEnd = end;\n  if (apptStart.isBefore(left)) apptStart = left.clone();\n  if (apptEnd.isAfter(right)) apptEnd = right.clone();\n  var pieceFrom = apptStart.clone();\n  var pieceTo = apptStart.clone();\n  var i = 0;\n\n  while (pieceTo.isBefore(apptEnd)) {\n    var currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');\n\n    if (currentRightBound.isAfter(apptStart)) {\n      pieceTo = apptStart.clone().add(step * i, 'days');\n\n      if (pieceTo.isAfter(currentRightBound)) {\n        pieceTo = currentRightBound.clone();\n      }\n\n      if (pieceTo.isAfter(apptEnd)) {\n        pieceTo = apptEnd.clone();\n      }\n\n      if (!pieceFrom.isSameOrAfter(pieceTo)) {\n        pieces.push(_assign({\n          start: pieceFrom,\n          end: pieceTo\n        }, restFields));\n        pieceFrom = pieceTo.clone().add(1, 'second');\n      }\n    }\n\n    i += 1;\n  }\n\n  return pieces;\n};\n\nvar getMonthCellIndexByDate = function getMonthCellIndexByDate(viewCellsData, date, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var startViewDate = moment(viewCellsData[0][0].startDate);\n  var currentDate = moment(date);\n  var cellIndex = currentDate.diff(startViewDate, 'days');\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n\n  return cellIndex;\n};\n\nvar TOP_CELL_OFFSET = 0.32;\nvar CELL_BOUND_OFFSET_PX = 1;\n\nvar getCellRect$1 = function getCellRect$1(date, viewCellsData, cellElementsMeta, takePrev, multiline) {\n  var cellIndex = multiline ? getMonthCellIndexByDate(viewCellsData, date, takePrev) : getAllDayCellIndexByDate(viewCellsData, date, takePrev);\n\n  var _a = cellElementsMeta.getCellRects[cellIndex](),\n      top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    height: height,\n    parentRect: parentRect\n  };\n};\n\nvar getHorizontalRectByDates = function getHorizontalRectByDates(startDate, endDate, _a) {\n  var multiline = _a.multiline,\n      viewCellsData = _a.viewCellsData,\n      cellElementsMeta = _a.cellElementsMeta;\n  var firstCellRect = getCellRect$1(startDate, viewCellsData, cellElementsMeta, false, multiline);\n  var lastCellRect = getCellRect$1(endDate, viewCellsData, cellElementsMeta, true, multiline);\n  var top = firstCellRect.top + firstCellRect.height * TOP_CELL_OFFSET;\n  var height = firstCellRect.height - firstCellRect.height * TOP_CELL_OFFSET;\n  return {\n    top: top - firstCellRect.parentRect.top,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_OFFSET_PX,\n    width: lastCellRect.left - firstCellRect.left + firstCellRect.width - CELL_BOUND_OFFSET_PX,\n    height: height,\n    parentWidth: firstCellRect.parentRect.width\n  };\n};\n\nvar DAY_COUNT = 7;\nvar MONTH_LENGTH = 31;\n\nvar monthCellsData = function monthCellsData(currentDate, firstDayOfWeek, intervalCount, today) {\n  if (intervalCount === void 0) {\n    intervalCount = 1;\n  }\n\n  var targetDate = moment(currentDate);\n  var currentMonths = [targetDate.month()];\n\n  while (currentMonths.length < intervalCount) {\n    currentMonths.push(targetDate.add(1, 'months').month());\n  }\n\n  var firstMonthDate = moment(currentDate).date(1);\n  var firstMonthDay = firstMonthDate.day() - firstDayOfWeek;\n  var prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;\n  var prevMonth = moment(currentDate).subtract(1, 'months');\n  var prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);\n  var from = moment().year(prevMonth.year()).month(prevMonth.month()).date(prevMonthStartDay).startOf('day');\n  var result = [];\n\n  while (result.length < Math.trunc(MONTH_LENGTH * intervalCount / DAY_COUNT) + 2) {\n    var week = [];\n\n    while (week.length < DAY_COUNT) {\n      week.push({\n        startDate: from.toDate(),\n        endDate: from.clone().add(1, 'day').toDate(),\n        otherMonth: currentMonths.findIndex(function (month) {\n          return month === from.month();\n        }) === -1,\n        today: today ? moment(today).isSame(from, 'date') : false\n      });\n      from.add(1, 'day');\n    }\n\n    result.push(week);\n  }\n\n  return result;\n};\n\nvar calculateMonthDateIntervals = function calculateMonthDateIntervals(appointments, leftBound, rightBound) {\n  return appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return _assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, [], false));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByWeek({\n      left: moment(leftBound),\n      right: moment(rightBound)\n    }, appointment, DAY_COUNT));\n  }, []);\n};\n\nvar calculateAllDayDateIntervals = function calculateAllDayDateIntervals(appointments, leftBound, rightBound, excludedDays) {\n  return appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return _assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false));\n  }, []).filter(function (appointment) {\n    return allDayPredicate(appointment);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays));\n  }, []);\n};\n\nvar allDayRects = function allDayRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellElementsMeta) {\n  var intervals = calculateAllDayDateIntervals(appointments, startViewDate, endViewDate, excludedDays);\n  return calculateRectByDateIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: false\n  }, intervals, getHorizontalRectByDates, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta,\n    excludedDays: excludedDays\n  });\n};\n\nvar verticalTimeTableRects = function verticalTimeTableRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration, cellElementsMeta) {\n  var intervals = calculateWeekDateIntervals(appointments, startViewDate, endViewDate, excludedDays, cellDuration);\n  return calculateRectByDateIntervals({\n    growDirection: VERTICAL_TYPE,\n    multiline: false\n  }, intervals, getVerticalRectByDates, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    cellElementsMeta: cellElementsMeta\n  });\n};\n\nvar horizontalTimeTableRects = function horizontalTimeTableRects(appointments, startViewDate, endViewDate, viewCellsData, cellElementsMeta) {\n  var intervals = calculateMonthDateIntervals(appointments, startViewDate, endViewDate);\n  return calculateRectByDateIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: true\n  }, intervals, getHorizontalRectByDates, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta\n  });\n};\n\nvar dateTimeFormatInstance = function dateTimeFormatInstance(locale, formatOptions) {\n  return new Intl.DateTimeFormat(locale, formatOptions);\n};\n\nvar appointments = function appointments(data) {\n  return data.map(function (appointment) {\n    return _assign(_assign(_assign(_assign({\n      dataItem: appointment,\n      start: appointment.startDate\n    }, appointment.endDate !== undefined ? {\n      end: appointment.endDate\n    } : {\n      end: appointment.startDate,\n      dataItem: _assign(_assign({}, appointment), {\n        endDate: appointment.startDate\n      })\n    }), appointment.allDay !== undefined && {\n      allDay: appointment.allDay\n    }), appointment.rRule !== undefined && {\n      rRule: appointment.rRule\n    }), appointment.exDate !== undefined && {\n      exDate: appointment.exDate\n    });\n  });\n};\n\nvar formatDateTimeGetter = function formatDateTimeGetter(locale) {\n  var cache = new Map(); // any -> type\n\n  var formatter = function formatter(nextDate, nextOptions) {\n    if (nextDate === undefined) return '';\n    var date = new Date(nextDate);\n    var formatInstance = cache.get(nextOptions);\n\n    if (!formatInstance) {\n      formatInstance = dateTimeFormatInstance(locale, nextOptions);\n      cache.set(nextOptions, formatInstance);\n    }\n\n    return formatInstance.format(date);\n  };\n\n  return formatter;\n};\n\nvar changeCurrentDate = function changeCurrentDate(currentDate, _a) {\n  var nextDate = _a.nextDate,\n      step = _a.step,\n      amount = _a.amount,\n      direction = _a.direction;\n  return nextDate || moment(currentDate)[direction === 'back' ? 'subtract' : 'add'](amount, step).toDate() || moment().subtract(amount, step);\n};\n\nvar setCurrentViewName = function setCurrentViewName(currentViewName, nextViewName) {\n  return nextViewName;\n};\n\nvar setAppointmentMeta = function setAppointmentMeta(prevAppointmentMeta, _a) {\n  var target = _a.target,\n      data = _a.data;\n  return {\n    target: target,\n    data: data\n  };\n};\n\nvar OPEN_COMMAND_BUTTON = 'open';\nvar CLOSE_COMMAND_BUTTON = 'close';\nvar DELETE_COMMAND_BUTTON = 'delete';\nvar CANCEL_COMMAND_BUTTON = 'cancel';\nvar COMMIT_COMMAND_BUTTON = 'commit';\n\nvar setAppointmentData = function setAppointmentData(prevAppointmentData, _a) {\n  var appointmentData = _a.appointmentData;\n  return appointmentData;\n};\n\nvar DEFAULT_RULE_OBJECT = {\n  interval: 1\n};\nvar DAYS_OF_WEEK = {\n  MONDAY: 0,\n  TUESDAY: 1,\n  WEDNESDAY: 2,\n  THURSDAY: 3,\n  FRIDAY: 4,\n  SATURDAY: 5,\n  SUNDAY: 6\n};\nvar DAYS_IN_WEEK = 7;\nvar DAYS_OF_WEEK_ARRAY = [DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY, DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY];\nvar MONTHS = {\n  JANUARY: 1,\n  FEBRUARY: 2,\n  MARCH: 3,\n  APRIL: 4,\n  MAY: 5,\n  JUNE: 6,\n  JULY: 7,\n  AUGUST: 8,\n  SEPTEMBER: 9,\n  OCTOBER: 10,\n  NOVEMBER: 11,\n  DECEMBER: 12\n};\nvar RRULE_REPEAT_TYPES = {\n  YEARLY: RRule.YEARLY,\n  MONTHLY: RRule.MONTHLY,\n  WEEKLY: RRule.WEEKLY,\n  DAILY: RRule.DAILY,\n  HOURLY: RRule.HOURLY,\n  MINUTELY: RRule.MINUTELY\n};\nvar REPEAT_TYPES = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n  NEVER: 'never'\n};\nvar REPEAT_TYPES_ARRAY = [REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY];\nvar WEEK_NUMBER_LABELS = ['firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel'];\nvar END_REPEAT_RADIO_GROUP = 'endRepeat';\nvar MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';\nvar YEARLY_RADIO_GROUP = 'yearlyRadioGroup';\nvar TITLE_TEXT_EDITOR = 'titleTextEditor';\nvar MULTILINE_TEXT_EDITOR = 'multilineTextEditor';\nvar ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';\nvar NUMBER_EDITOR = 'numberEditor';\nvar TITLE = 'title';\nvar ORDINARY_LABEL = 'ordinaryLabel';\nvar SAVE_BUTTON = 'saveButton';\nvar DELETE_BUTTON = 'deleteButton';\nvar CANCEL_BUTTON = 'cancelButton';\nvar OUTLINED_SELECT = 'outlinedSelect';\nvar STANDARD_SELECT = 'standardSelect';\nvar SUNDAY_DATE = new Date(2019, 7, 11);\nvar MONDAY_DATE = new Date(2019, 7, 12);\nvar TUESDAY_DATE = new Date(2019, 7, 13);\nvar WEDNESDAY_DATE = new Date(2019, 7, 14);\nvar THURSDAY_DATE = new Date(2019, 7, 15);\nvar FRIDAY_DATE = new Date(2019, 7, 16);\nvar SATURDAY_DATE = new Date(2019, 7, 17);\nvar DAYS_OF_WEEK_DATES = [SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE, THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE];\nvar JANUARY_DATE = new Date(2019, 0, 1);\nvar FEBRUARY_DATE = new Date(2019, 1, 1);\nvar MARCH_DATE = new Date(2019, 2, 1);\nvar APRIL_DATE = new Date(2019, 3, 1);\nvar MAY_DATE = new Date(2019, 4, 1);\nvar JUNE_DATE = new Date(2019, 5, 1);\nvar JULY_DATE = new Date(2019, 6, 1);\nvar AUGUST_DATE = new Date(2019, 7, 1);\nvar SEPTEMBER_DATE = new Date(2019, 8, 1);\nvar OCTOBER_DATE = new Date(2019, 9, 1);\nvar NOVEMBER_DATE = new Date(2019, 10, 1);\nvar DECEMBER_DATE = new Date(2019, 11, 1);\nvar MONTHS_DATES = [JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE, JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE];\nvar FIRST_WEEK = 0;\nvar SECOND_WEEK = 1;\nvar THIRD_WEEK = 2;\nvar FOURTH_WEEK = 3;\nvar LAST_WEEK = 4;\nvar BASIC_YEALY_COUNT = 5;\nvar BASIC_MONTHLY_COUNT = 12;\nvar BASIC_WEEKLY_COUNT = 13;\nvar BASIC_DAILY_COUNT = 30;\n\nvar getWeekNumberLabels = function getWeekNumberLabels(getMessage) {\n  return WEEK_NUMBER_LABELS.map(function (weekNumberLabel, index) {\n    return {\n      text: getMessage(weekNumberLabel),\n      id: index\n    };\n  });\n};\n\nvar getDaysOfWeek = function getDaysOfWeek(formatDate, firstDayOfWeek) {\n  var daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);\n  var daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);\n  return daysOfWeekDates.map(function (day, index) {\n    return {\n      text: getDayOfWeek(day, formatDate),\n      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0]\n    };\n  });\n};\n\nvar getMonths = function getMonths(formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonth(month, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthsWithOf = function getMonthsWithOf(getMessage, formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonthWithOf(month, getMessage, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthWithOf = function getMonthWithOf(date, getMessage, formatDate) {\n  return getMessage('ofLabel') + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\\d.,]/g, '').toString();\n};\n\nvar getMonth = function getMonth(date, formatDate) {\n  return formatDate(date, LONG_MONTH_OPTIONS);\n};\n\nvar getDayOfWeek = function getDayOfWeek(date, formatDate) {\n  return formatDate(date, LONG_WEEK_DAY_OPTIONS);\n};\n\nvar getMonthId = function getMonthId(index) {\n  return index + 1;\n};\n\nvar getAvailableRecurrenceOptions = function getAvailableRecurrenceOptions(getMessage) {\n  return REPEAT_TYPES_ARRAY.map(function (type) {\n    return {\n      text: getMessage(type),\n      id: type\n    };\n  });\n};\n\nvar getCountDependingOnRecurrenceType = function getCountDependingOnRecurrenceType(frequency) {\n  var count;\n\n  switch (frequency) {\n    case RRULE_REPEAT_TYPES.YEARLY:\n      count = BASIC_YEALY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.MONTHLY:\n      count = BASIC_MONTHLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.WEEKLY:\n      count = BASIC_WEEKLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.DAILY:\n      count = BASIC_DAILY_COUNT;\n      break;\n  }\n\n  return count;\n};\n\nvar checkIsNaturalNumber = function checkIsNaturalNumber(number) {\n  return number > 0 && number <= Number.MAX_SAFE_INTEGER;\n};\n\nvar callActionIfExists = function callActionIfExists(action, payload) {\n  if (action) {\n    action(payload);\n  }\n};\n\nvar isAllDayCell = function isAllDayCell(startDate, endDate) {\n  return moment(endDate).diff(moment(startDate), 'days') >= 1;\n};\n\nvar changeRecurrenceFrequency = function changeRecurrenceFrequency(rule, freq, startDate) {\n  if (!rule) {\n    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {\n      return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n      return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        bymonth: startDate.getMonth() + 1,\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n      freq: freq,\n      count: getCountDependingOnRecurrenceType(freq)\n    })).toString();\n  }\n\n  var options = RRule.parseString(rule);\n  if (options.freq === freq) return rule;\n  options.freq = freq;\n  options.count = getCountDependingOnRecurrenceType(freq);\n\n  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonthday = startDate.getDate();\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonth = startDate.getMonth() + 1;\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {\n    options.bymonthday = undefined;\n  }\n\n  options.byweekday = undefined;\n  var nextRule = new RRule(options);\n  return nextRule.toString();\n};\n\nvar getRecurrenceOptions = function getRecurrenceOptions(rule) {\n  if (!rule) return null;\n  var options = RRule.parseString(rule);\n\n  if (options.byweekday) {\n    var byweekday = options.byweekday.map(function (weekDay) {\n      return weekDay.weekday;\n    });\n    options.byweekday = byweekday;\n  }\n\n  return options;\n};\n\nvar changeRecurrenceOptions = function changeRecurrenceOptions(options) {\n  return options ? new RRule(_assign({}, options)).toString() : undefined;\n};\n\nvar handleStartDateChange = function handleStartDateChange(nextStartDay, options) {\n  if (nextStartDay <= 31) {\n    var nextOptions = _assign(_assign({}, options), {\n      bymonthday: nextStartDay\n    });\n\n    return changeRecurrenceOptions(nextOptions);\n  }\n\n  return changeRecurrenceOptions(options);\n};\n\nvar handleToDayOfWeekChange = function handleToDayOfWeekChange(weekNumber, dayOfWeek, options) {\n  var nextOptions = setByMonthDay(weekNumber, options);\n  nextOptions.byweekday = dayOfWeek > 0 ? dayOfWeek - 1 : 6;\n  return changeRecurrenceOptions(nextOptions);\n};\n\nvar handleWeekNumberChange = function handleWeekNumberChange(nextWeekNumber, options) {\n  return changeRecurrenceOptions(setByMonthDay(nextWeekNumber, options));\n};\n\nvar getRRuleFrequency = function getRRuleFrequency(repeatType) {\n  return RRULE_REPEAT_TYPES[repeatType.toUpperCase()];\n};\n\nvar getFrequencyString = function getFrequencyString(rRuleFrequency) {\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY) return REPEAT_TYPES.DAILY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY) return REPEAT_TYPES.WEEKLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY) return REPEAT_TYPES.MONTHLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY) return REPEAT_TYPES.YEARLY;\n  return REPEAT_TYPES.NEVER;\n};\n\nvar setByMonthDay = function setByMonthDay(nextWeekNumber, options) {\n  if (nextWeekNumber < 4) {\n    return _assign(_assign({}, options), {\n      bymonthday: [nextWeekNumber * 7 + 1, nextWeekNumber * 7 + 2, nextWeekNumber * 7 + 3, nextWeekNumber * 7 + 4, nextWeekNumber * 7 + 5, nextWeekNumber * 7 + 6, nextWeekNumber * 7 + 7]\n    });\n  }\n\n  return _assign(_assign({}, options), {\n    bymonthday: [-1, -2, -3, -4, -5, -6, -7]\n  });\n};\n\nvar getRadioGroupDisplayData = function getRadioGroupDisplayData(recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption) {\n  var weekNumber = LAST_WEEK;\n\n  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {\n    return {\n      dayNumberTextField: recurrenceOptions.bymonthday,\n      weekNumber: stateWeekNumber,\n      dayOfWeek: stateDayOfWeek,\n      radioGroupValue: firstOption\n    };\n  }\n\n  if (!recurrenceOptions.byweekday) {\n    return {\n      dayOfWeek: stateDayOfWeek,\n      weekNumber: stateWeekNumber,\n      radioGroupValue: secondOption,\n      dayNumberTextField: stateDayNumber\n    };\n  }\n\n  var dayOfWeek = recurrenceOptions.byweekday[0] < 6 ? recurrenceOptions.byweekday[0] + 1 : 0;\n\n  if (recurrenceOptions.bymonthday && recurrenceOptions.bymonthday[0] > 0) {\n    weekNumber = Math.trunc(recurrenceOptions.bymonthday[0] / 7);\n  }\n\n  return {\n    dayOfWeek: dayOfWeek,\n    weekNumber: weekNumber,\n    radioGroupValue: secondOption,\n    dayNumberTextField: stateDayNumber\n  };\n};\n\nvar handleChangeFrequency = function handleChangeFrequency(repeatType, rRule, startDate, action) {\n  var rruleRepeatType = getRRuleFrequency(repeatType);\n  var nextRRule;\n\n  if (rruleRepeatType !== undefined) {\n    nextRRule = changeRecurrenceFrequency(rRule, rruleRepeatType, startDate);\n  }\n\n  action({\n    rRule: nextRRule\n  });\n};\n\nvar handleWeekDaysChange = function handleWeekDaysChange(options, weekDay) {\n  var byWeekDay = options.byweekday || [];\n  var index = byWeekDay.indexOf(weekDay);\n  var isAdded = !(index > -1);\n\n  if (isAdded) {\n    byWeekDay.push(weekDay);\n  } else if (index > -1) {\n    byWeekDay.splice(index, 1);\n  }\n\n  if (byWeekDay === 0) return _assign(_assign({}, options), {\n    byweekday: undefined\n  });\n  return _assign(_assign({}, options), {\n    byweekday: byWeekDay\n  });\n};\n\nvar getDaysOfWeekArray = function getDaysOfWeekArray(firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1;\n  });\n  var secondPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1;\n  });\n  return firstDayOfWeek !== 0 ? __spread(firstPart, secondPart) : __spread(secondPart, firstPart);\n};\n\nvar getDaysOfWeekDates = function getDaysOfWeekDates(firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);\n  var secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);\n  return __spread(firstPart, secondPart);\n};\n\nvar addAppointment = function addAppointment(addedAppointmentData, _a) {\n  var appointmentData = (_a === void 0 ? {\n    appointmentData: {}\n  } : _a).appointmentData;\n  return appointmentData;\n};\n\nvar cancelAddedAppointment = function cancelAddedAppointment() {\n  return {};\n};\n\nvar startEditAppointment = function startEditAppointment(prevEditingAppointment, appointmentData) {\n  return appointmentData;\n};\n\nvar stopEditAppointment = function stopEditAppointment() {\n  return undefined;\n};\n\nvar changeAppointment = function changeAppointment(appointment, _a) {\n  var change = _a.change;\n  return _assign(_assign({}, appointment), change);\n};\n\nvar cancelChanges = function cancelChanges() {\n  return {};\n};\n\nvar changedAppointmentById = function changedAppointmentById(changes, appointmentId) {\n  var _a;\n\n  return _a = {}, _a[appointmentId] = changes, _a;\n};\n\nvar mergeNewChanges = function mergeNewChanges(appointmentData, changes) {\n  var appointment = _assign({}, appointmentData);\n\n  delete appointment.id;\n  delete appointment.rRule;\n  delete appointment.exDate;\n  delete appointment.parentData;\n  return _assign(_assign({}, appointment), changes);\n};\n\nvar reduceExDate = function reduceExDate(prevExDate, boundDate) {\n  if (prevExDate.length > 0) {\n    return prevExDate.split(',').reduce(function (acc, date) {\n      var momentDate = moment.utc(date);\n\n      if (momentDate.isBefore(boundDate)) {\n        return __spread(acc, [date]);\n      }\n\n      return acc;\n    }, []).join(',');\n  }\n\n  return undefined;\n};\n\nvar configureExDate = function configureExDate(exDate, date) {\n  var currentExDate = moment.utc(date).format('YYYYMMDDTHHmmss') + \"Z\";\n  return exDate ? exDate + \",\" + currentExDate : currentExDate;\n};\n\nvar configureDateSequence = function configureDateSequence(rRule, exDate, prevStartDate, nextStartDate) {\n  var rruleSet = getRRuleSetWithExDates(exDate);\n  var currentOptions = RRule.parseString(rRule);\n  var correctedOptions = currentOptions.until ? _assign(_assign({}, currentOptions), {\n    until: moment(getUTCDate(currentOptions.until)).toDate()\n  }) : currentOptions;\n  var prevStartDateUTC = moment(getUTCDate(prevStartDate)).toDate();\n  rruleSet.rrule(new RRule(_assign(_assign({}, correctedOptions), {\n    dtstart: prevStartDateUTC\n  })));\n\n  if (currentOptions.count || currentOptions.until) {\n    return rruleSet.all() // we shouldn't use `new Date(string)` because this function has different results in Safari\n    .map(function (nextDate) {\n      return moment(formatDateToString(nextDate)).toDate();\n    });\n  }\n\n  var leftBound = prevStartDateUTC;\n  var rightBound = moment(getUTCDate(nextStartDate)).toDate();\n  return rruleSet.between(leftBound, rightBound, true).map(function (nextDate) {\n    return moment(formatDateToString(nextDate)).toDate();\n  });\n};\n\nvar configureICalendarRules = function configureICalendarRules(rRule, options) {\n  var rruleSet = new RRuleSet();\n  rruleSet.rrule(new RRule(_assign(_assign({}, RRule.parseString(rRule)), options)));\n  return rruleSet.valueOf();\n};\n\nvar changeCurrentAndFollowing = function changeCurrentAndFollowing(appointmentData, changes, changeAllAction) {\n  var _a;\n\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      parentData = appointmentData.parentData,\n      _b = appointmentData.exDate,\n      prevExDate = _b === void 0 ? '' : _b,\n      id = appointmentData.id;\n\n  var _c = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _c.initialSequence,\n      currentChildIndex = _c.currentChildIndex;\n\n  if (currentChildIndex === 0) return changeAllAction(appointmentData, changes);\n  var changedRules = configureICalendarRules(rRule, {\n    dtstart: moment.utc(parentData.startDate).toDate(),\n    until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),\n    count: null\n  });\n  var nextExDate = reduceExDate(prevExDate, startDate);\n  return {\n    changed: (_a = {}, _a[id] = _assign({\n      rRule: changedRules[1].slice(6)\n    }, nextExDate && prevExDate !== nextExDate ? {\n      exDate: nextExDate\n    } : {}), _a)\n  };\n};\n\nvar getAppointmentSequenceData = function getAppointmentSequenceData(prevStartDate, startDate, exDate, rRule) {\n  var initialSequence = configureDateSequence(rRule, exDate, moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate());\n  var currentChildIndex = initialSequence.findIndex(function (date) {\n    return moment(date).isSame(startDate);\n  });\n  return {\n    initialSequence: initialSequence,\n    currentChildIndex: currentChildIndex\n  };\n};\n\nvar deleteCurrent = function deleteCurrent(appointmentData) {\n  var _a;\n\n  var currentSequence = configureDateSequence(appointmentData.rRule, appointmentData.exDate, moment.utc(appointmentData.parentData.startDate).toDate(), moment.utc(appointmentData.startDate).toDate());\n\n  if (currentSequence.length === 1) {\n    return deleteAll(appointmentData);\n  }\n\n  var nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate);\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: nextExDate\n    }, _a)\n  };\n};\n\nvar deleteAll = function deleteAll(appointmentData) {\n  return {\n    deleted: appointmentData.id\n  };\n};\n\nvar deleteCurrentAndFollowing = function deleteCurrentAndFollowing(appointmentData) {\n  return changeCurrentAndFollowing(appointmentData, {}, deleteAll);\n};\n\nvar editAll = function editAll(appointmentData, changes) {\n  var _a, _b;\n\n  var rRule = appointmentData.rRule,\n      id = appointmentData.id;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  if (changes.startDate && moment.utc(changes.startDate).isAfter(initialRule.options.until)) {\n    return {\n      changed: (_a = {}, _a[id] = _assign(_assign({}, changes), {\n        rRule: 'FREQ=DAILY;COUNT=1',\n        exDate: ''\n      }), _a)\n    };\n  }\n\n  return {\n    changed: (_b = {}, _b[appointmentData.id] = changes, _b)\n  };\n};\n\nvar editCurrent = function editCurrent(appointmentData, changes) {\n  var _a;\n\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate)\n    }, _a),\n    added: mergeNewChanges(appointmentData, changes)\n  };\n};\n\nvar editCurrentAndFollowing = function editCurrentAndFollowing(appointmentData, changes) {\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      _a = appointmentData.exDate,\n      prevExDate = _a === void 0 ? '' : _a,\n      parentData = appointmentData.parentData;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  var _b = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _b.initialSequence,\n      currentChildIndex = _b.currentChildIndex;\n\n  if (currentChildIndex === 0) return editAll(appointmentData, changes);\n  var addedOptions = initialRule.options.count || initialRule.options.until ? {\n    count: initialSequence.length - currentChildIndex\n  } : {};\n  var addedRules = configureICalendarRules(appointmentData.rRule, _assign({\n    dtstart: moment.utc(startDate).toDate()\n  }, addedOptions));\n  var addedAppointment = moment.utc(changes.startDate).isAfter(initialRule.options.until) ? {\n    rRule: 'FREQ=DAILY;COUNT=1',\n    exDate: ''\n  } : {\n    rRule: addedRules[1].slice(6)\n  };\n  return {\n    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,\n    added: _assign(_assign({}, addedAppointment), mergeNewChanges(appointmentData, changes))\n  };\n};\n\nvar preCommitChanges = function preCommitChanges(changes, appointmentData, editType) {\n  if (changes === null) {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return deleteAll(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return deleteCurrent(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return deleteCurrentAndFollowing(appointmentData);\n        }\n    }\n  } else {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return editAll(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return editCurrent(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return editCurrentAndFollowing(appointmentData, changes);\n        }\n    }\n  }\n\n  return {};\n};\n\nvar clamp = function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar calculateInsideOffset = function calculateInsideOffset(targetType, insidePart, cellDurationMinutes) {\n  return targetType === VERTICAL_TYPE ? insidePart * cellDurationMinutes * 60 / 2 : 0;\n};\n\nvar cellType = function cellType(data) {\n  return moment(data.startDate).isSame(data.endDate, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE;\n};\n\nvar intervalDuration = function intervalDuration(data, type) {\n  return moment(data.endDate).diff(data.startDate, type);\n};\n\nvar cellIndex = function cellIndex(getCellRects, clientOffset) {\n  return getCellRects.findIndex(function (getCellRect) {\n    var _a = getCellRect(),\n        left = _a.left,\n        top = _a.top,\n        right = _a.right,\n        bottom = _a.bottom;\n\n    var isOver = clientOffset && clamp(clientOffset.x, left, right) === clientOffset.x && clamp(clientOffset.y, top, bottom) === clientOffset.y;\n    return isOver;\n  });\n};\n\nvar cellData = function cellData(timeTableIndex, allDayIndex, viewCellsData) {\n  if (allDayIndex !== -1) {\n    var allDayCellsData = allDayCells(viewCellsData);\n    return allDayCellsData[allDayIndex];\n  }\n\n  var firstIndex = Math.floor(timeTableIndex / viewCellsData[0].length);\n  var secondIndex = timeTableIndex % viewCellsData[0].length;\n  return viewCellsData[firstIndex][secondIndex];\n};\n\nvar autoScroll = function autoScroll(clientOffset, scrollingStrategy) {\n  if (clientOffset.y < scrollingStrategy.topBoundary + SCROLL_OFFSET && clientOffset.y > scrollingStrategy.topBoundary) {\n    scrollingStrategy.changeVerticalScroll(-SCROLL_SPEED_PX);\n  }\n\n  if (scrollingStrategy.bottomBoundary - SCROLL_OFFSET < clientOffset.y) {\n    scrollingStrategy.changeVerticalScroll(+SCROLL_SPEED_PX);\n  }\n};\n\nvar timeBoundariesByResize = function timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart) {\n  if (targetType !== payload.appointmentType) {\n    return {\n      appointmentStartTime: undefined,\n      appointmentEndTime: undefined\n    };\n  }\n\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var sourceType = payload.type;\n\n  if (sourceType === RESIZE_TOP) {\n    var insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n    appointmentStartTime = moment(targetData.startDate).add(insideTopOffset, SECONDS).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  if (sourceType === RESIZE_BOTTOM) {\n    var insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE ? cellDurationMinutes * 60 / 2 : 0;\n    appointmentEndTime = moment(targetData.endDate).add(-insideBottomOffset, SECONDS).toDate();\n    appointmentStartTime = moment(payload.startDate).toDate();\n  } // keep origin appointment duration if coordinates are wrong\n\n\n  if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {\n    appointmentStartTime = moment(payload.startDate).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime\n  };\n};\n\nvar timeBoundariesByDrag = function timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  if (targetType === HORIZONTAL_TYPE && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {\n    return {\n      appointmentStartTime: targetData.startDate,\n      appointmentEndTime: targetData.endDate,\n      offsetTimeTop: 0\n    };\n  }\n\n  var offsetTimeTop;\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n  var start = moment(targetData.startDate).add(insideOffset, SECONDS);\n\n  if (offsetTimeTopBase === null) {\n    offsetTimeTop = moment(targetData.startDate).diff(payload.startDate, SECONDS) + insideOffset;\n  } else {\n    offsetTimeTop = offsetTimeTopBase;\n  }\n\n  if (payload.type === targetType) {\n    var appointmentDurationSeconds = intervalDuration(payload, SECONDS);\n    appointmentStartTime = moment(start).add(offsetTimeTop * -1, SECONDS).toDate();\n    appointmentEndTime = moment(start).add(appointmentDurationSeconds - offsetTimeTop, SECONDS).toDate();\n  } else {\n    appointmentStartTime = moment(targetData.startDate).add(insideOffset, SECONDS).toDate();\n    appointmentEndTime = moment(targetData.endDate).add(insideOffset, SECONDS).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime,\n    offsetTimeTop: offsetTimeTop\n  };\n};\n\nvar calculateAppointmentTimeBoundaries = function calculateAppointmentTimeBoundaries(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  var isDragging = payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE;\n  return isDragging ? timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) : timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart);\n};\n\nvar calculateInsidePart = function calculateInsidePart(top, timeTableCellsRects, timeTableIndex) {\n  if (timeTableIndex !== undefined && timeTableIndex !== -1) {\n    var cellRect = timeTableCellsRects[timeTableIndex]();\n    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;\n  }\n\n  return 0;\n};\n\nvar calculateDraftAppointments = function calculateDraftAppointments(allDayIndex, draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, targetType, cellDurationMinutes, getTableCellElementRects) {\n  if (allDayIndex !== -1 || targetType === VERTICAL_TYPE && getAllDayCellsElementRects.getCellRects.length && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23) {\n    var allDayDrafts = draftAppointments.map(function (draftAppt) {\n      return _assign(_assign({}, draftAppt), {\n        allDay: true\n      });\n    });\n    return {\n      allDayDraftAppointments: allDayRects(allDayDrafts, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects),\n      timeTableDraftAppointments: []\n    };\n  }\n\n  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {\n    return {\n      allDayDraftAppointments: [],\n      timeTableDraftAppointments: verticalTimeTableRects(draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects)\n    };\n  }\n\n  return {\n    allDayDraftAppointments: [],\n    timeTableDraftAppointments: horizontalTimeTableRects(draftAppointments, startViewDate, endViewDate, viewCellsData, getTableCellElementRects)\n  };\n};\n\nvar isMonthCell = function isMonthCell(otherMonth) {\n  return otherMonth !== undefined;\n};\n\nvar isShadedAppointment = function isShadedAppointment(_a, currentTime, shadePreviousAppointments) {\n  var appointmentData = _a.data;\n  var momentCurrentDate = moment(currentTime);\n\n  if (appointmentData.allDay) {\n    return momentCurrentDate.isAfter(appointmentData.endDate, 'day') && shadePreviousAppointments;\n  }\n\n  if (momentCurrentDate.isAfter(appointmentData.endDate)) {\n    return shadePreviousAppointments;\n  }\n\n  return false;\n};\n\nvar getCurrentTimeIndicatorTop = function getCurrentTimeIndicatorTop(cellData, currentTime) {\n  var top = (currentTime - cellData.startDate.getTime()) * 100 / (cellData.endDate.getTime() - cellData.startDate.getTime());\n  return top < 0 || top > 100 ? undefined : top + \"%\";\n};\n\nvar isCellShaded = function isCellShaded(_a, currentTime, shadePreviousCells) {\n  var startDate = _a.startDate,\n      endDate = _a.endDate,\n      otherMonth = _a.otherMonth;\n  var monthCell = isMonthCell(otherMonth);\n  return (startDate.getTime() < currentTime && !monthCell || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;\n};\n\nvar convertResourcesToPlain = function convertResourcesToPlain(validResources) {\n  return validResources.reduce(function (acc, resource) {\n    return __spread(acc, resource.instances.map(function (item) {\n      return item;\n    }));\n  }, []);\n};\n\nvar validateResources = function validateResources(resources, mainResourceName, palette) {\n  var isMainResourceDefined = !!mainResourceName;\n  var currentPaletteIndex = 0;\n  return resources.map(function (resource, groupIndex) {\n    var fieldName = resource.fieldName;\n    var isMain = isMainResourceDefined && mainResourceName === fieldName || groupIndex === 0 && !isMainResourceDefined;\n    var title = resource.title || fieldName;\n    var allowMultiple = !!resource.allowMultiple;\n    return {\n      fieldName: fieldName,\n      isMain: isMain,\n      title: title,\n      allowMultiple: allowMultiple,\n      instances: resource.instances.map(function (resourceItem) {\n        var color = resourceItem.color || palette[currentPaletteIndex];\n        if (!resourceItem.color) currentPaletteIndex += 1;\n        return {\n          id: resourceItem.id,\n          color: color,\n          fieldName: fieldName,\n          text: resourceItem.text || title || fieldName,\n          title: title,\n          allowMultiple: allowMultiple,\n          isMain: isMain\n        };\n      })\n    };\n  });\n};\n\nvar getAppointmentResources = function getAppointmentResources(appointment, resources, plainResources) {\n  if (!resources || resources.length === 0 || !plainResources || plainResources.length === 0) return [];\n  return resources.reduce(function (acc, resource) {\n    var appointmentResourceId = appointment[resource.fieldName];\n    if (appointmentResourceId === undefined) return acc;\n\n    if (resource.allowMultiple && !Array.isArray(appointmentResourceId) || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {\n      // throw error\n      return acc;\n    }\n\n    if (resource.allowMultiple) {\n      return __spread(acc, appointmentResourceId.map(function (itemId) {\n        return plainResources.find(function (plainItem) {\n          return resource.fieldName === plainItem.fieldName && plainItem.id === itemId;\n        });\n      }));\n    }\n\n    return __spread(acc, plainResources.find(function (plainItem) {\n      return resource.fieldName === plainItem.fieldName && plainItem.id === appointmentResourceId;\n    }));\n  }, []);\n};\n/** @internal */\n\n\nvar RecurrenceFrequency;\n\n(function (RecurrenceFrequency) {\n  RecurrenceFrequency[RecurrenceFrequency[\"Daily\"] = RRULE_REPEAT_TYPES.DAILY] = \"Daily\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Weekly\"] = RRULE_REPEAT_TYPES.WEEKLY] = \"Weekly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Monthly\"] = RRULE_REPEAT_TYPES.MONTHLY] = \"Monthly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Yearly\"] = RRULE_REPEAT_TYPES.YEARLY] = \"Yearly\";\n})(RecurrenceFrequency || (RecurrenceFrequency = {}));\n\nexport { APRIL_DATE, AUGUST_DATE, AUTO_HEIGHT, BASIC_DAILY_COUNT, BASIC_MONTHLY_COUNT, BASIC_WEEKLY_COUNT, BASIC_YEALY_COUNT, CANCEL_BUTTON, CANCEL_COMMAND_BUTTON, CLOSE_COMMAND_BUTTON, COMMIT_COMMAND_BUTTON, DAYS_IN_WEEK, DAYS_OF_WEEK, DAYS_OF_WEEK_ARRAY, DAYS_OF_WEEK_DATES, DAY_LONG_MONTH_LONG_YEAR_OPTIONS, DAY_LONG_MONTH_OPTIONS, DAY_OPTIONS, DAY_SHORT_MONTH_LONG_YEAR_OPTIONS, DAY_SHORT_MONTH_OPTIONS, DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS, DECEMBER_DATE, DEFAULT_RULE_OBJECT, DELETE_BUTTON, DELETE_COMMAND_BUTTON, EMPTY_OPTIONS, END_REPEAT_RADIO_GROUP, FEBRUARY_DATE, FIRST_WEEK, FOURTH_WEEK, FRIDAY_DATE, HORIZONTAL_TYPE, HOURS, HOUR_MINUTE_OPTIONS, JANUARY_DATE, JULY_DATE, JUNE_DATE, LAST_WEEK, LONG_MONTH_OPTIONS, LONG_WEEK_DAY_OPTIONS, MARCH_DATE, MAY_DATE, MINUTES, MONDAY_DATE, MONTHLY_RADIO_GROUP, MONTHS, MONTHS_DATES, MONTH_YEAR_OPTIONS, MULTILINE_TEXT_EDITOR, NOVEMBER_DATE, NUMBER_EDITOR, OCTOBER_DATE, OPEN_COMMAND_BUTTON, ORDINARY_LABEL, ORDINARY_TEXT_EDITOR, OUTLINED_SELECT, POSITION_END, POSITION_START, RECURRENCE_EDIT_SCOPE, REPEAT_TYPES, REPEAT_TYPES_ARRAY, RESIZE_BOTTOM, RESIZE_TOP, RRULE_REPEAT_TYPES, RecurrenceFrequency, SATURDAY_DATE, SAVE_BUTTON, SCROLL_OFFSET, SCROLL_SPEED_PX, SECONDS, SECOND_WEEK, SEPTEMBER_DATE, SHORT_MONTH_LONG_YEAR_OPTIONS, SHORT_MONTH_OPTIONS, SHORT_MONTH_SHORT_YEAR_OPTIONS, STANDARD_SELECT, SUNDAY_DATE, THIRD_WEEK, THURSDAY_DATE, TITLE, TITLE_TEXT_EDITOR, TOGGLE_APPOINTMENT_FORM_VISIBILITY, TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY, TUESDAY_DATE, VERTICAL_TYPE, WEDNESDAY_DATE, WEEKDAY_INTERVAL, WEEK_DAY_OPTIONS, WEEK_NUMBER_LABELS, YEARLY_RADIO_GROUP, addAppointment, adjustAppointments, allDayCells, allDayPredicate, allDayRects, appointments, autoScroll, availableViews, calculateAllDayDateIntervals, calculateAppointmentTimeBoundaries, calculateDraftAppointments, calculateFirstDateOfWeek, calculateInsidePart, calculateMonthDateIntervals, calculateRectByDateIntervals, calculateWeekDateIntervals, callActionIfExists, cancelAddedAppointment, cancelChanges, cellData, cellIndex, cellType, changeAppointment, changeCurrentDate, changeRecurrenceFrequency, changeRecurrenceOptions, changedAppointmentById, checkIsNaturalNumber, computed, convertResourcesToPlain, dayBoundaryPredicate, dayScale, deleteAll, deleteCurrent, deleteCurrentAndFollowing, editAll, editCurrent, editCurrentAndFollowing, endViewDate, filterByViewBoundaries, findOverlappedAppointments, formatDateTimeGetter, formatDateToString, getAllDayCellIndexByDate, getAppointmentResources, getAppointmentStyle, getAvailableRecurrenceOptions, getCellByDate, getCountDependingOnRecurrenceType, getCurrentTimeIndicatorTop, getDaysOfWeek, getDaysOfWeekArray, getDaysOfWeekDates, getFrequencyString, getHorizontalRectByDates, getMonthCellIndexByDate, getMonths, getMonthsWithOf, getRRuleFrequency, getRRuleSetWithExDates, getRadioGroupDisplayData, getRecurrenceOptions, getUTCDate, getVerticalRectByDates, getViewType, getWeekNumberLabels, handleChangeFrequency, handleStartDateChange, handleToDayOfWeekChange, handleWeekDaysChange, handleWeekNumberChange, horizontalTimeTableRects, intervalDuration, isAllDayCell, isCellShaded, isMidnight$1 as isMidnight, isMonthCell, isShadedAppointment, monthCellsData, normalizeAppointmentDuration, preCommitChanges, reduceAppointmentByDayBounds, setAppointmentData, setAppointmentMeta, setCurrentViewName, sliceAppointmentByDay, sliceAppointmentByWeek, sliceAppointmentsByBoundaries, sortAppointments, startEditAppointment, startViewDate, stopEditAppointment, timeBoundariesByDrag, timeBoundariesByResize, timeScale, toPercentage, unwrapGroups, validateResources, verticalTimeTableRects, viewBoundText, viewCellsData, viewPredicate };","map":{"version":3,"sources":["../src/constants.ts","../src/utils.ts","../src/plugins/common/helpers.ts","../src/plugins/common/computeds.ts","../src/plugins/week-view/helpers.ts","../src/plugins/week-view/computeds.ts","../src/plugins/vertical-rect/helpers.ts","../src/plugins/all-day-panel/helpers.ts","../src/plugins/month-view/helpers.ts","../src/plugins/horizontal-rect/helpers.ts","../src/plugins/month-view/computeds.ts","../src/plugins/all-day-panel/computeds.ts","../src/plugins/common/calculate-rects.ts","../src/plugins/scheduler-core/helpers.ts","../src/plugins/scheduler-core/computeds.ts","../src/plugins/view-state/reducers.ts","../src/plugins/appointment-tooltip/reducers.ts","../src/plugins/appointment-tooltip/constants.ts","../src/plugins/appointment-form/reducers.ts","../src/plugins/appointment-form/constants.ts","../src/plugins/appointment-form/utils.ts","../src/plugins/appointment-form/helpers.ts","../src/plugins/editing-state/reducers.ts","../src/plugins/editing-state/computeds.ts","../src/plugins/editing-state/helpers.ts","../src/plugins/drag-drop-provider/helpers.ts","../src/plugins/current-time-indicator/helpers.tsx","../src/plugins/resources/computeds.ts","../src/plugins/resources/helpers.ts","../src/types/appointment-form.types.ts"],"names":["isMidnight","getCellRect","allDayCellsCore"],"mappings":"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","sourcesContent":["export const VERTICAL_TYPE = 'vertical';\nexport const HORIZONTAL_TYPE = 'horizontal';\n\nexport const SCROLL_OFFSET = 50;\nexport const SCROLL_SPEED_PX = 30;\n\nexport const SECONDS = 'seconds';\nexport const MINUTES = 'minutes';\nexport const HOURS = 'hours';\n\nexport const RESIZE_TOP = 'resize-start';\nexport const RESIZE_BOTTOM = 'resize-end';\n\nexport const POSITION_START = 'start';\nexport const POSITION_END = 'end';\n\nexport const AUTO_HEIGHT = 'auto';\n\nexport const DAY_OPTIONS = { day: 'numeric' };\nexport const WEEK_DAY_OPTIONS = { weekday: 'short' };\nexport const SHORT_MONTH_OPTIONS = { month: 'short' };\nexport const HOUR_MINUTE_OPTIONS = { hour: 'numeric', minute: 'numeric' };\nexport const MONTH_YEAR_OPTIONS = { month: 'long', year: 'numeric' };\nexport const DAY_SHORT_MONTH_OPTIONS = { day: 'numeric', month: 'short' };\nexport const SHORT_MONTH_LONG_YEAR_OPTIONS = { month: 'short', year: 'numeric' };\nexport const SHORT_MONTH_SHORT_YEAR_OPTIONS = { month: 'short', year: '2-digit' };\nexport const DAY_LONG_MONTH_LONG_YEAR_OPTIONS = { day: 'numeric', month: 'long', year: 'numeric' };\nexport const DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric', month: 'short', year: 'numeric',\n};\nexport const DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  day: 'numeric', month: 'short', year: '2-digit',\n};\nexport const LONG_WEEK_DAY_OPTIONS = { weekday: 'long' };\nexport const LONG_MONTH_OPTIONS = { month: 'long' };\nexport const DAY_LONG_MONTH_OPTIONS = { day: 'numeric', month: 'long' };\nexport const EMPTY_OPTIONS = {};\n\nexport const RECURRENCE_EDIT_SCOPE = {\n  ALL: 'all',\n  CURRENT_AND_FOLLOWING: 'currentAndFollowing',\n  CURRENT: 'current',\n};\n\nexport const TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';\nexport const TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';\n\nexport const WEEKDAY_INTERVAL = 'weekdayInterval';\n","import moment from 'moment';\nimport { CustomFunction, PureComputed } from '@devexpress/dx-core';\nimport { RRule, RRuleSet } from 'rrule';\nimport { HORIZONTAL_TYPE, VERTICAL_TYPE } from './constants';\nimport {\n  ComputedHelperFn, ViewPredicateFn,\n  CalculateFirstDateOfWeekFn, AppointmentMoment,\n  Interval, AppointmentGroup, AppointmentUnwrappedGroup,\n  Rect, ElementRect, RectCalculatorBaseFn, CalculateRectByDateIntervalsFn,\n} from './types';\n\nexport const computed: ComputedHelperFn = (getters, viewName, baseComputed, defaultValue) => {\n  if (getters.currentView.name !== viewName && !!defaultValue) {\n    return defaultValue;\n  }\n  return baseComputed(getters, viewName);\n};\n\nconst appointmentHeightType = (appointment: AppointmentMoment, cellDuration: number) => {\n  const durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;\n  if (durationRatio === 1) return 'middle';\n  if (durationRatio > 1) return 'long';\n  return 'short';\n};\n\nexport const toPercentage: PureComputed<\n  [number, number]\n> = (value, total) => (value * 100) / total;\n\nconst createExcludedInterval: CustomFunction<\n  [number, moment.Moment], Interval\n> = (day, start) => {\n  const leftBound = moment(start.day(day));\n  return [\n    leftBound,\n    moment(leftBound).hour(start.hour()).endOf('day'),\n  ];\n};\n\nconst excludedIntervals: PureComputed<\n  [number[], moment.Moment], Interval[]\n> = (excludedDays, start) => excludedDays\n  .map(day => (day === 0 ? 7 : day))\n  .sort((a, b) => a - b)\n  .reduce((acc, day, i, allDays) => {\n    if (i && day === allDays[i - 1] + 1) {\n      acc[i - 1][1].day(day);\n    } else {\n      acc.push(createExcludedInterval(day, start));\n    }\n    return acc;\n  }, [] as Interval[]);\n\nconst byDayPredicate: PureComputed<\n  [moment.Moment, moment.Moment], boolean\n> = (boundary, date) => (\n  boundary.isSameOrAfter(date, 'day')\n  && !boundary.isSame(boundary.clone().startOf('day'))\n);\n\nconst inInterval = (\n  date: moment.Moment, interval: Interval,\n) => date.isBetween(interval[0], interval[1], undefined, '[]');\n\nexport const viewPredicate: ViewPredicateFn = (\n  appointment, left, right,\n  excludedDays = [],\n  removeAllDayAppointments = false,\n) => {\n  const { start, end } = appointment;\n  const isAppointmentInBoundary = end.isAfter(left as Date)\n    && start.isBefore(right as Date);\n\n  const isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left as Date))\n    .find(interval => (inInterval(start, interval) && inInterval(end, interval)));\n  const considerAllDayAppointment = removeAllDayAppointments\n    ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay\n    : true;\n\n  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;\n};\n\nconst compareByDay: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.start.isBefore(second.start, 'day')) return -1;\n  if (first.start.isAfter(second.start, 'day')) return 1;\n  return 0;\n};\n\nconst compareByAllDay: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.allDay && !second.allDay) return -1;\n  if (!first.allDay && second.allDay) return 1;\n  return 0;\n};\n\nconst compareByTime: PureComputed<\n  [AppointmentMoment, AppointmentMoment], number\n> = (first, second) => {\n  if (first.start.isBefore(second.start)) return -1;\n  if (first.start.isAfter(second.start)) return 1;\n  if (first.end.isBefore(second.end)) return 1;\n  if (first.end.isAfter(second.end)) return -1;\n  return 0;\n};\n\nexport const sortAppointments: PureComputed<\n  [AppointmentMoment[]], AppointmentMoment[]\n> = appointments => appointments\n  .slice().sort((a, b) => compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b));\n\nexport const findOverlappedAppointments: CustomFunction<\n  [AppointmentMoment[], boolean], any[]\n> = (sortedAppointments, byDay = false) => {\n  const appointments = sortedAppointments.slice();\n  const groups: AppointmentMoment[][] = [];\n  let totalIndex = 0;\n\n  while (totalIndex < appointments.length) {\n    groups.push([]);\n    const current = appointments[totalIndex];\n    const currentGroup = groups[groups.length - 1];\n    let next = appointments[totalIndex + 1];\n    let maxBoundary = current.end;\n\n    currentGroup.push(current);\n    totalIndex += 1;\n    while (next && (maxBoundary.isAfter(next.start)\n      || (byDay && byDayPredicate(maxBoundary, next.start)))) {\n      currentGroup.push(next);\n      if (maxBoundary.isBefore(next.end)) maxBoundary = next.end;\n      totalIndex += 1;\n      next = appointments[totalIndex];\n    }\n  }\n  return groups;\n};\n\nconst isMidnight: PureComputed<\n  [moment.Moment], boolean\n> = date => date.isSame(date.clone().startOf('day'));\n\nconst maxBoundaryPredicate: PureComputed<\n  [moment.Moment, Date], boolean\n> = (maxBoundary, startDate) => ((maxBoundary.isBefore(startDate as Date, 'day'))\n  || (isMidnight(maxBoundary) && maxBoundary.isSame(startDate as Date, 'day')));\n\nexport const adjustAppointments: CustomFunction<\n  [any[], boolean], any\n> = (groups, byDay = false) => groups.map((items) => {\n  let offset = 0;\n  let reduceValue = 1;\n  const appointments = items.slice();\n  const groupLength = appointments.length;\n  for (let startIndex = 0; startIndex < groupLength; startIndex += 1) {\n    const appointment = appointments[startIndex];\n    if (appointment.offset === undefined) {\n      let maxBoundary = appointment.end;\n      appointment.offset = offset;\n      for (let index = startIndex + 1; index < groupLength; index += 1) {\n        if (appointments[index].offset === undefined) {\n          if ((!byDay && maxBoundary.isSameOrBefore(appointments[index].start))\n            || (byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start))) {\n            maxBoundary = appointments[index].end;\n            appointments[index].offset = offset;\n          }\n        }\n      }\n\n      offset += 1;\n      if (reduceValue < offset) reduceValue = offset;\n    }\n  }\n  return { items: appointments, reduceValue };\n});\n\nexport const calculateFirstDateOfWeek: CalculateFirstDateOfWeekFn = (\n  currentDate, firstDayOfWeek, excludedDays = [],\n) => {\n  const currentLocale = moment.locale();\n  moment.updateLocale('tmp-locale', {\n    week: { dow: firstDayOfWeek, doy: 1 }, // `doy` is required for TS using\n  });\n  const firstDateOfWeek = moment(currentDate as Date).startOf('week');\n  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {\n    excludedDays.slice().sort().forEach((day) => {\n      if (day === firstDateOfWeek.day()) {\n        firstDateOfWeek.add(1, 'days');\n      }\n    });\n  }\n  moment.locale(currentLocale);\n\n  return firstDateOfWeek.toDate();\n};\n\nexport const unwrapGroups: PureComputed<\n  [AppointmentGroup[]], AppointmentUnwrappedGroup[]\n> = groups => groups.reduce((acc, { items, reduceValue }) => {\n  acc.push(...items.map(appointment => ({\n    start: appointment.start,\n    end: appointment.end,\n    dataItem: appointment.dataItem,\n    offset: appointment.offset,\n    reduceValue,\n    fromPrev: moment(appointment.start).diff(appointment.dataItem.startDate, 'minutes') > 1,\n    toNext: moment(appointment.dataItem.endDate).diff(appointment.end, 'minutes') > 1,\n  })));\n  return acc;\n}, [] as AppointmentUnwrappedGroup[]);\n\nexport const getAppointmentStyle: PureComputed<\n  [Rect], React.CSSProperties\n> = ({\n  top, left,\n  width, height,\n}) => ({\n  height,\n  width: `${width}%`,\n  transform: `translateY(${top}px)`,\n  msTransform: `translateY(${top}px)`,\n  left: `${left}%`,\n  position: 'absolute',\n});\n\nconst rectCalculatorBase: RectCalculatorBaseFn = (\n  appointment,\n  getRectByDates,\n  options,\n) => getRectByDates(appointment.start, appointment.end, options);\n\nconst horizontalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, any], ElementRect\n> = (\n  appointment,\n  {\n    rectByDates,\n    multiline,\n    rectByDatesMeta: {\n      cellElementsMeta,\n      viewCellsData,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = rectCalculatorBase(\n    appointment,\n    rectByDates,\n    {\n      multiline,\n      cellElementsMeta,\n      viewCellsData,\n    },\n  );\n\n  return {\n    top: top + ((height / appointment.reduceValue) * appointment.offset),\n    height: height / appointment.reduceValue,\n    left: toPercentage(left, parentWidth),\n    width: toPercentage(width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    type: HORIZONTAL_TYPE,\n  };\n};\n\nconst verticalRectCalculator: CustomFunction<\n  [AppointmentUnwrappedGroup, any], ElementRect\n> = (\n  appointment,\n  {\n    rectByDates,\n    multiline,\n    rectByDatesMeta: {\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n      excludedDays,\n    },\n  },\n) => {\n  const {\n    top, left,\n    width, height, parentWidth,\n  } = rectCalculatorBase(\n    appointment,\n    rectByDates,\n    {\n      multiline,\n      viewCellsData,\n      cellDuration,\n      excludedDays,\n      cellElementsMeta,\n    },\n  );\n\n  const widthInPx = width / appointment.reduceValue;\n\n  return {\n    top,\n    height,\n    left: toPercentage(left + (widthInPx * appointment.offset), parentWidth),\n    width: toPercentage(widthInPx, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE,\n  };\n};\n\nexport const calculateRectByDateIntervals: CalculateRectByDateIntervalsFn = (\n  type, intervals, rectByDates, rectByDatesMeta,\n) => {\n  const { growDirection, multiline } = type;\n  const isHorizontal = growDirection === HORIZONTAL_TYPE;\n\n  const sorted = sortAppointments(intervals);\n  const grouped = findOverlappedAppointments(sorted as AppointmentMoment[], isHorizontal);\n\n  const rectCalculator = isHorizontal\n    ? horizontalRectCalculator\n    : verticalRectCalculator;\n\n  return unwrapGroups(adjustAppointments(grouped, isHorizontal))\n    .map(appointment => rectCalculator(appointment, { rectByDates, multiline, rectByDatesMeta }));\n};\n\nconst expandRecurrenceAppointment = (\n  appointment: AppointmentMoment, leftBound: Date, rightBound: Date,\n) => {\n  const rightBoundUTC = moment(getUTCDate(rightBound)).toDate();\n  const leftBoundUTC = moment(getUTCDate(leftBound)).toDate();\n  const appointmentStartDate = moment(appointment.start).toDate();\n  const options = {\n    ...RRule.parseString(appointment.rRule),\n    dtstart: moment(getUTCDate(appointmentStartDate)).toDate(),\n  };\n  const correctedOptions = options.until\n    ? { ...options, until: moment(getUTCDate(options.until)).toDate() }\n    : options;\n\n  const rruleSet = getRRuleSetWithExDates(appointment.exDate);\n\n  rruleSet.rrule(new RRule(correctedOptions));\n\n  // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates\n  // we have to format the dates we get from RRuleSet to get local dates\n  const datesInBoundaries = rruleSet.between(leftBoundUTC as Date, rightBoundUTC as Date, true)\n    .map(formatDateToString);\n  if (datesInBoundaries.length === 0) return [];\n\n  const appointmentDuration = moment(appointment.end)\n    .diff(appointment.start, 'minutes');\n\n  return datesInBoundaries.map((startDate, index) => ({\n    ...appointment,\n    dataItem: {\n      ...appointment.dataItem,\n      startDate: moment(startDate).toDate(),\n      endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(),\n      parentData: appointment.dataItem,\n    },\n    start: moment(startDate),\n    end: moment(startDate).add(appointmentDuration, 'minutes'),\n  }));\n};\n\nexport const filterByViewBoundaries: PureComputed<\n  [AppointmentMoment, Date, Date, number[], boolean], AppointmentMoment[]\n> = (appointment, leftBound, rightBound, excludedDays, removeAllDay) => {\n  let appointments = [appointment];\n  if (appointment.rRule) {\n    appointments = expandRecurrenceAppointment(\n      appointment as AppointmentMoment, leftBound as Date, rightBound as Date,\n    );\n  }\n  return appointments.filter(appt => viewPredicate(\n    appt, leftBound, rightBound, excludedDays, removeAllDay,\n  ));\n};\n\nexport const getUTCDate: PureComputed<[Date], number> = date =>\n  Date.UTC(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    date.getMinutes(),\n);\n\nexport const getRRuleSetWithExDates: PureComputed<\n  [string | undefined], RRuleSet\n> = (exDate) => {\n  const rruleSet = new RRuleSet();\n  if (exDate) {\n    exDate.split(',').map((date: string) => {\n      const currentExDate = moment(date).toDate();\n      rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());\n    });\n  }\n  return rruleSet;\n};\n\nexport const formatDateToString = (date: Date | string | number) => moment.utc(date).format('YYYY-MM-DDTHH:mm');\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE, DAY_OPTIONS, SHORT_MONTH_OPTIONS,\n  DAY_SHORT_MONTH_OPTIONS, SHORT_MONTH_LONG_YEAR_OPTIONS,\n  SHORT_MONTH_SHORT_YEAR_OPTIONS, MONTH_YEAR_OPTIONS,\n  DAY_LONG_MONTH_LONG_YEAR_OPTIONS, DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS,\n  DAY_SHORT_MONTH_LONG_YEAR_OPTIONS, LONG_WEEK_DAY_OPTIONS, EMPTY_OPTIONS, WEEKDAY_INTERVAL,\n} from '../../constants';\nimport { ViewBoundTextFn, FormatterFn } from '../../types';\n\nconst MONTH_TYPE = 'month';\n\nexport const getViewType: PureComputed<[string], string> = (currentViewType) => {\n  if (currentViewType === MONTH_TYPE) return HORIZONTAL_TYPE;\n  return VERTICAL_TYPE;\n};\n\nexport const isMidnight: PureComputed<\n  [Date], boolean\n> = (date) => {\n  const momentDate = moment(date as Date);\n  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;\n};\n\nconst calculateTextByDays: PureComputed<\n  [Date, Date, FormatterFn, object], string\n> = (startViewDate, endViewDate, formatDate, additionalOptions) => {\n  const momentStartViewDate = moment(startViewDate as Date);\n  const momentEndViewDate = moment(endViewDate as Date);\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {\n    return formatDate(momentStartViewDate.toDate(), {\n      ...DAY_LONG_MONTH_LONG_YEAR_OPTIONS, ...additionalOptions,\n    });\n  }\n  if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {\n    if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {\n      return `${\n        formatDate(momentStartViewDate.toDate(), DAY_OPTIONS)\n      }-${\n        formatDate(momentEndViewDate.toDate(), DAY_OPTIONS)\n      } ${\n        formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS)\n      }`;\n    }\n    return `${\n      formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS)\n    } - ${\n      formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS)\n    }`;\n  }\n  return `${\n    formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  } - ${\n    formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  }`;\n};\n\nconst calculateTextByMonths: PureComputed<\n  [Date, number, FormatterFn], string\n> = (currentDate, intervalCount, formatDate) => {\n  const momentCurrentDate = moment(currentDate as Date);\n\n  if (intervalCount === 1) {\n    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);\n  }\n  const lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');\n  if (momentCurrentDate.isSame(lastMonth, 'year')) {\n    return `${\n      formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS)\n    }-${\n      formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS)\n    }`;\n  }\n  return `${\n    formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  } - ${\n    formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS)\n  }`;\n};\n\nexport const viewBoundText: ViewBoundTextFn = (\n  startViewDate, endViewDate, type, currentDate, intervalCount, formatDate,\n) => (type !== 'month'\n  ? calculateTextByDays(\n    startViewDate, endViewDate, formatDate,\n    type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS,\n  )\n  : calculateTextByMonths(currentDate, intervalCount, formatDate)\n);\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TimeScale, SchedulerDateTime, ViewCell,\n  DayScaleFn, TimeScaleFn, ViewCellsDataFn, AllDayCell,\n  SchedulerView,\n} from '../../types';\nimport { calculateFirstDateOfWeek } from '../../utils';\nimport { isMidnight } from './helpers';\n\nconst subtractSecond: PureComputed<\n  [Date]\n> = date => moment(date as Date).subtract(1, 'second').toDate();\n\nexport const dayScale: DayScaleFn = (\n  currentDate,\n  firstDayOfWeek,\n  dayCount,\n  excluded = [],\n) => {\n  const result: Date[] = [];\n  const date = firstDayOfWeek !== undefined\n    ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded) as Date)\n    : moment(currentDate as Date);\n  for (let index = 0; index < dayCount; index += 1) {\n    if (excluded.findIndex(item => item === date.day()) === -1) {\n      result.push(date.toDate());\n    }\n    date.add(1, 'days');\n  }\n  return result;\n};\n\nexport const timeScale: TimeScaleFn = (\n  currentDate,\n  firstDayOfWeek,\n  startDayHour,\n  endDayHour,\n  cellDuration,\n  excludedDays,\n) => {\n  const result: TimeScale[] = [];\n  const startDateOfView = firstDayOfWeek !== undefined\n    ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays)\n    : currentDate;\n  const left = moment(startDateOfView as Date)\n    .startOf('day')\n    .add(startDayHour, 'hour');\n  const right = moment(startDateOfView as Date)\n    .startOf('day')\n    .add(endDayHour, 'hour');\n\n  while (left.isBefore(right)) {\n    const startDate = left.toDate();\n    left.add(cellDuration, 'minutes');\n    result.push({ start: startDate, end: left.toDate() });\n  }\n\n  const timeScaleLastIndex = result.length - 1;\n  if (isMidnight(result[timeScaleLastIndex].end)) {\n    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end) as Date;\n  }\n  return result;\n};\n\nexport const availableViews: PureComputed<\n  [SchedulerView[], string, string], SchedulerView[]\n> = (views, viewName, viewDisplayName) => {\n  if (!views) return [{ name: viewName, displayName: viewDisplayName }];\n  if (views.findIndex(view => viewName === view.name) === -1) {\n    const nextViews = views.slice();\n    nextViews.push({ name: viewName, displayName: viewDisplayName });\n    return nextViews;\n  }\n  return views;\n};\n\nexport const viewCellsData: ViewCellsDataFn = (\n  currentDate, firstDayOfWeek,\n  dayCount, excludedDays,\n  startDayHour, endDayHour,\n  cellDuration, currTime,\n) => {\n  const days = dayScale(currentDate, firstDayOfWeek!, dayCount!, excludedDays);\n  const times = timeScale(\n    currentDate, firstDayOfWeek!, startDayHour, endDayHour, cellDuration, excludedDays,\n  );\n  const currentTime = moment(currTime as SchedulerDateTime);\n\n  return times.reduce((cellsAcc, time) => {\n    const start = moment(time.start);\n    const end = moment(time.end);\n    const rowCells = days.reduce((rowAcc, day) => {\n      const startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();\n      const endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();\n      const today = currentTime.isSame(startDate, 'day');\n      rowAcc.push({ startDate, endDate, today });\n      return rowAcc;\n    }, [] as ViewCell[]);\n    cellsAcc.push(rowCells);\n    return cellsAcc;\n  }, [] as ViewCell[][]);\n};\n\nexport const allDayCells: PureComputed<\n  [ViewCell[][]], AllDayCell[]\n> = viewCells => viewCells[0].map(cell => ({\n  startDate: moment(cell.startDate).startOf('day').toDate(),\n  endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate(),\n}));\n\nexport const startViewDate: PureComputed<\n  [ViewCell[][]], Date\n> = viewCells => moment(viewCells[0][0].startDate).toDate();\n\nexport const endViewDate: PureComputed<\n  [ViewCell[][]], Date\n> = (viewCells) => {\n  const lastRowIndex = viewCells.length - 1;\n  const lastCellIndex = viewCells[lastRowIndex].length - 1;\n  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate!);\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  AppointmentMoment, DayBoundaryPredicateFn,\n  ReduceAppointmentByDayBoundsFn, NormalizeAppointmentDurationFn,\n} from '../../types';\n\nexport const sliceAppointmentByDay: PureComputed<\n  [AppointmentMoment, number], AppointmentMoment[]\n> = (appointment, cellDuration) => {\n  const { start, end, dataItem } = appointment;\n  if (start.isSame(end, 'day')) return [appointment];\n\n  const minDuration = cellDuration / 2;\n  const isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;\n  const isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;\n\n  return [\n    isShortOnFirstDay ? {\n      start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n      end: start.clone().endOf('day'),\n      dataItem,\n    } : {\n      start, end: start.clone().endOf('day'), dataItem,\n    },\n    isShortOnSecondDay ? {\n      start: end.clone().startOf('day'),\n      end: end.clone().startOf('day').add(minDuration, 'minutes'),\n      dataItem,\n    } : {\n      start: end.clone().startOf('day'), end, dataItem,\n    },\n  ];\n};\n\nexport const dayBoundaryPredicate: DayBoundaryPredicateFn = (\n  appointment,\n  leftBound, rightBound,\n  excludedDays = [],\n) => {\n  const dayStart = moment(leftBound as Date);\n  const dayEnd = moment(rightBound as Date);\n  const startDayTime = moment(appointment.start)\n    .hour(dayStart.hour())\n    .minutes(dayStart.minutes());\n  const endDayTime = moment(appointment.start)\n    .hour(dayEnd.hour())\n    .minutes(dayEnd.minutes());\n\n  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd)) return false;\n  if (excludedDays.findIndex(day => day === moment(appointment.start).day()) !== -1) return false;\n  return (appointment.end.isAfter(startDayTime)\n    && appointment.start.isBefore(endDayTime));\n};\n\nexport const reduceAppointmentByDayBounds: ReduceAppointmentByDayBoundsFn = (\n  appointment, leftBound, rightBound, cellDuration,\n) => {\n  const dayStart = moment(leftBound as Date);\n  const dayEnd = moment(rightBound as Date);\n  const startDayTime = moment(appointment.start)\n    .hour(dayStart.hour())\n    .minutes(dayStart.minutes())\n    .seconds(dayStart.seconds());\n  const endDayTime = moment(appointment.start)\n    .hour(dayEnd.hour())\n    .minutes(dayEnd.minutes())\n    .seconds(dayEnd.seconds());\n\n  const minDuration = cellDuration / 2;\n  const isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;\n  const isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;\n\n  if (isShortOnFirstDay) {\n    return {\n      ...appointment, start: endDayTime.clone().add(-minDuration, 'minutes'), end: endDayTime,\n    };\n  }\n\n  if (isShortOnSecondDay) {\n    return {\n      ...appointment, start: startDayTime, end: startDayTime.clone().add(minDuration, 'minutes'),\n    };\n  }\n\n  return {\n    ...appointment,\n    ...(appointment.start.isSameOrBefore(startDayTime) ? { start: startDayTime } : null),\n    ...(appointment.end.isSameOrAfter(endDayTime) ? { end: endDayTime } : null),\n  };\n};\n\nexport const normalizeAppointmentDuration: NormalizeAppointmentDurationFn = (\n  appointment, cellDuration,\n) => {\n  const minDuration = cellDuration / 2;\n  const start = moment(appointment.start as Date);\n  const end = moment(appointment.end as Date);\n\n  if (end.diff(start, 'minutes') > minDuration) {\n    return { ...appointment, start, end };\n  }\n\n  if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {\n    return { ...appointment, start, end: start.clone().add(minDuration, 'minutes') };\n  }\n\n  return {\n    ...appointment,\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day'),\n  };\n};\n","import { CalculateWeekDateIntervalsFn, AppointmentMoment } from '../../types';\nimport {\n  sliceAppointmentByDay, dayBoundaryPredicate, reduceAppointmentByDayBounds,\n  normalizeAppointmentDuration,\n} from './helpers';\nimport { filterByViewBoundaries } from '../../utils';\n\nexport const calculateWeekDateIntervals: CalculateWeekDateIntervalsFn = (\n  appointments,\n  leftBound, rightBound, // startViewDate, endViewDate\n  excludedDays,\n  cellDuration,\n) => appointments\n  .map(appointment => normalizeAppointmentDuration(appointment, cellDuration))\n  .reduce((acc, appointment) =>\n    [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true)],\n    [] as AppointmentMoment[],\n  )\n  .reduce((acc, appointment) => (\n    [...acc, ...sliceAppointmentByDay(appointment, cellDuration)]), [] as AppointmentMoment[],\n  )\n  .filter(appointment => dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays))\n  .map(appointment => reduceAppointmentByDayBounds(\n    appointment, leftBound, rightBound, cellDuration,\n  ));\n","import moment from 'moment';\nimport {\n  GetCellByDateFn, GetVerticalRectByDatesFn, GetCellRectVerticalFn, SchedulerDateTime,\n} from '../../types';\n\nconst CELL_GAP_PX = 10;\nconst CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;\nconst CELL_BOUND_VERTICAL_OFFSET_PX = 4;\n\nexport const getCellByDate: GetCellByDateFn = (viewCellsData, date, takePrev = false) => {\n  const cellIndex =\n    viewCellsData[0].findIndex(timeCell => moment(date as SchedulerDateTime)\n      .isSame(timeCell.startDate, 'date'));\n\n  const rowIndex = viewCellsData.findIndex(timeCell => moment(date as SchedulerDateTime)\n    .isBetween(\n      timeCell[cellIndex].startDate,\n      timeCell[cellIndex].endDate,\n      'seconds',\n      takePrev ? '(]' : '[)'),\n    );\n\n  const totalCellIndex = (rowIndex * viewCellsData[0].length) + cellIndex;\n  return {\n    index: totalCellIndex,\n    startDate: viewCellsData[rowIndex][cellIndex].startDate,\n  };\n};\n\nconst getCellRect: GetCellRectVerticalFn = (\n  date, viewCellsData, cellDuration, cellElementsMeta, takePrev,\n) => {\n  const {\n    index: cellIndex,\n    startDate: cellStartDate,\n  } = getCellByDate(viewCellsData, date, takePrev);\n\n  const {\n    top,\n    left,\n    width,\n    height: cellHeight,\n  } = cellElementsMeta.getCellRects[cellIndex]();\n\n  const timeOffset = moment(date as SchedulerDateTime).diff(cellStartDate as Date, 'minutes');\n  const topOffset = cellHeight * (timeOffset / cellDuration);\n  const parentRect = cellElementsMeta.parentRect();\n\n  return {\n    top,\n    left,\n    width,\n    topOffset,\n    parentRect,\n  };\n};\n\nexport const getVerticalRectByDates: GetVerticalRectByDatesFn = (\n  startDate,\n  endDate,\n  {\n    viewCellsData,\n    cellDuration,\n    cellElementsMeta,\n  },\n) => {\n  const firstCellRect = getCellRect(\n    startDate, viewCellsData, cellDuration, cellElementsMeta, false,\n  );\n  const lastCellRect = getCellRect(endDate, viewCellsData, cellDuration, cellElementsMeta, true);\n\n  const top = firstCellRect.top + firstCellRect.topOffset;\n  const height = (lastCellRect.top + lastCellRect.topOffset) - top;\n\n  return {\n    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    parentWidth: firstCellRect.parentRect.width,\n    height: height - CELL_BOUND_VERTICAL_OFFSET_PX,\n  };\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  AppointmentMoment, GetAllDayCellIndexByDateFn,\n  SliceAppointmentsByBoundariesFn, SchedulerDateTime,\n} from '../../types';\n\nexport const allDayPredicate: PureComputed<[AppointmentMoment], boolean> = appointment => (\n  appointment.end.diff(appointment.start, 'hours') > 23\n  || !!appointment.allDay\n);\n\nexport const getAllDayCellIndexByDate: GetAllDayCellIndexByDateFn = (\n  viewCellsData, date, takePrev,\n) => {\n  const currentDate = moment(date as SchedulerDateTime);\n  let cellIndex = viewCellsData[0]\n    .findIndex(day => moment(day.startDate).day() === currentDate.day());\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n  return cellIndex;\n};\n\nexport const sliceAppointmentsByBoundaries: SliceAppointmentsByBoundariesFn = (\n  appointment, left, right, excludedDays = [],\n) => {\n  const startDate = appointment.start.clone();\n  const endDate = appointment.end.clone();\n  let nextStart = startDate.clone();\n  let nextEnd = endDate.clone();\n\n  if (startDate.isBefore(left as Date)) {\n    nextStart = moment(left as Date);\n    nextStart.startOf('day');\n  }\n  if (endDate.isAfter(right as Date)) {\n    nextEnd = moment(right as Date);\n    nextEnd.endOf('day');\n  }\n  if (excludedDays.findIndex(day => day === startDate.day()) !== -1) {\n    while (excludedDays.findIndex(day => day === nextStart.day()) !== -1\n      && nextStart.isSameOrBefore(endDate, 'day')) {\n      nextStart.add(1, 'days').startOf('day');\n    }\n  }\n  if (excludedDays.findIndex(day => day === endDate.day()) !== -1) {\n    while (excludedDays.findIndex(day => day === nextEnd.day()) !== -1\n      && nextStart.isSameOrAfter(startDate, 'day')) {\n      nextEnd.add(-1, 'days').endOf('day');\n    }\n  }\n  return [{ ...appointment, start: nextStart, end: nextEnd }];\n};\n","import moment from 'moment';\nimport {\n  SliceAppointmentByWeekFn, GetMonthCellIndexByDateFn, SchedulerDateTime, AppointmentMoment,\n} from '../../types';\n\nexport const sliceAppointmentByWeek: SliceAppointmentByWeekFn = (timeBounds, appointment, step) => {\n  const { left, right } = timeBounds;\n  const pieces: AppointmentMoment[] = [];\n  const { start, end, ...restFields } = appointment;\n  let apptStart = start;\n  let apptEnd = end;\n  if (apptStart.isBefore(left)) apptStart = left.clone();\n  if (apptEnd.isAfter(right)) apptEnd = right.clone();\n  let pieceFrom = apptStart.clone();\n  let pieceTo = apptStart.clone();\n  let i = 0;\n  while (pieceTo.isBefore(apptEnd)) {\n    const currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');\n    if (currentRightBound.isAfter(apptStart)) {\n      pieceTo = apptStart.clone().add(step * i, 'days');\n      if (pieceTo.isAfter(currentRightBound)) {\n        pieceTo = currentRightBound.clone();\n      }\n      if (pieceTo.isAfter(apptEnd)) {\n        pieceTo = apptEnd.clone();\n      }\n      if (!pieceFrom.isSameOrAfter(pieceTo)) {\n        pieces.push({ start: pieceFrom, end: pieceTo, ...restFields });\n        pieceFrom = pieceTo.clone().add(1, 'second');\n      }\n    }\n    i += 1;\n  }\n  return pieces;\n};\n\nexport const getMonthCellIndexByDate: GetMonthCellIndexByDateFn = (\n  viewCellsData, date, takePrev = false,\n) => {\n  const startViewDate = moment(viewCellsData[0][0].startDate);\n  const currentDate = moment(date as SchedulerDateTime);\n  let cellIndex = currentDate.diff(startViewDate, 'days');\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n\n  return cellIndex;\n};\n","import { GetCellRectHorizontalFn, GetHorizontalRectByDatesFn } from '../../types';\nimport { getAllDayCellIndexByDate } from '../all-day-panel/helpers';\nimport { getMonthCellIndexByDate } from '../month-view/helpers';\n\nconst TOP_CELL_OFFSET = 0.32;\nconst CELL_BOUND_OFFSET_PX = 1;\n\nconst getCellRect: GetCellRectHorizontalFn = (\n  date, viewCellsData, cellElementsMeta, takePrev, multiline,\n) => {\n  const cellIndex = multiline\n    ? getMonthCellIndexByDate(viewCellsData, date, takePrev)\n    : getAllDayCellIndexByDate(viewCellsData, date, takePrev);\n\n  const {\n    top,\n    left,\n    width,\n    height,\n  } = cellElementsMeta.getCellRects[cellIndex]();\n  const parentRect = cellElementsMeta.parentRect();\n  return {\n    top,\n    left,\n    width,\n    height,\n    parentRect,\n  };\n};\n\nexport const getHorizontalRectByDates: GetHorizontalRectByDatesFn = (\n  startDate,\n  endDate,\n  {\n    multiline,\n    viewCellsData,\n    cellElementsMeta,\n  },\n) => {\n  const firstCellRect = getCellRect(startDate, viewCellsData, cellElementsMeta, false, multiline);\n  const lastCellRect = getCellRect(endDate, viewCellsData, cellElementsMeta, true, multiline);\n\n  const top = firstCellRect.top + (firstCellRect.height * TOP_CELL_OFFSET);\n  const height = firstCellRect.height - (firstCellRect.height * TOP_CELL_OFFSET);\n\n  return {\n    top: top - firstCellRect.parentRect.top,\n    left: (firstCellRect.left - firstCellRect.parentRect.left) + CELL_BOUND_OFFSET_PX,\n    width: ((lastCellRect.left - firstCellRect.left) + firstCellRect.width) - CELL_BOUND_OFFSET_PX,\n    height,\n    parentWidth: firstCellRect.parentRect.width,\n  };\n};\n","import moment from 'moment';\nimport {\n  MonthCellsDataComputedFn, MonthCellData,\n  CalculateMonthDateIntervalsFn, AppointmentMoment,\n} from '../../types';\nimport { filterByViewBoundaries } from '../../utils';\nimport { sliceAppointmentByWeek } from './helpers';\n\nconst DAY_COUNT = 7;\nconst MONTH_LENGTH = 31;\n\nexport const monthCellsData: MonthCellsDataComputedFn = (\n  currentDate,\n  firstDayOfWeek,\n  intervalCount = 1,\n  today,\n) => {\n  const targetDate = moment(currentDate as Date);\n  const currentMonths = [targetDate.month()];\n  while (currentMonths.length < intervalCount) {\n    currentMonths.push(targetDate.add(1, 'months').month());\n  }\n  const firstMonthDate = moment(currentDate as Date).date(1);\n  const firstMonthDay = firstMonthDate.day() - firstDayOfWeek;\n  const prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;\n  const prevMonth = moment(currentDate as Date).subtract(1, 'months');\n  const prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);\n  const from = moment()\n    .year(prevMonth.year())\n    .month(prevMonth.month())\n    .date(prevMonthStartDay)\n    .startOf('day');\n\n  const result: MonthCellData[][] = [];\n  while (result.length < (Math.trunc((MONTH_LENGTH * intervalCount) / DAY_COUNT) + 2)) {\n    const week: MonthCellData[] = [];\n    while (week.length < DAY_COUNT) {\n      week.push({\n        startDate: from.toDate(),\n        endDate: from.clone().add(1, 'day').toDate(),\n        otherMonth: currentMonths.findIndex(month => month === from.month()) === -1,\n        today: today ? moment(today as Date).isSame(from, 'date') : false,\n      });\n      from.add(1, 'day');\n    }\n    result.push(week);\n  }\n  return result;\n};\n\nexport const calculateMonthDateIntervals: CalculateMonthDateIntervalsFn = (\n  appointments, leftBound, rightBound,\n) => appointments\n  .map(({ start, end, ...restArgs }) => ({ start: moment(start), end: moment(end), ...restArgs }))\n  .reduce((acc, appointment) =>\n    [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, [], false)],\n    [] as AppointmentMoment[],\n  )\n  .reduce((acc, appointment) => ([\n    ...acc,\n    ...sliceAppointmentByWeek(\n      { left: moment(leftBound as Date), right: moment(rightBound as Date) },\n      appointment,\n      DAY_COUNT,\n    ),\n  ]), [] as AppointmentMoment[]);\n","import moment from 'moment';\nimport {\n  AppointmentMoment, CalculateAllDayDateIntervalsFn,\n} from '../../types';\nimport { allDayPredicate, sliceAppointmentsByBoundaries } from './helpers';\nimport { filterByViewBoundaries } from '../../utils';\n\nexport const calculateAllDayDateIntervals: CalculateAllDayDateIntervalsFn = (\n  appointments,\n  leftBound, rightBound,\n  excludedDays,\n) => appointments\n  .map(({ start, end, ...restArgs }) => ({ start: moment(start), end: moment(end), ...restArgs }))\n  .reduce((acc, appointment) =>\n    [...acc, ...filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false)],\n    [] as AppointmentMoment[],\n  )\n  .filter(appointment => allDayPredicate(appointment))\n  .reduce((acc, appointment) => ([\n    ...acc,\n    ...sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays),\n  ]), [] as AppointmentMoment[]);\n","import {\n  AllDayRects, VerticalRects, HorizontalRects,\n} from '../../types';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE,\n} from '../../constants';\nimport { calculateRectByDateIntervals } from '../../utils';\nimport { calculateWeekDateIntervals } from '../week-view/computeds';\nimport { getVerticalRectByDates } from '../vertical-rect/helpers';\nimport { getHorizontalRectByDates } from '../horizontal-rect/helpers';\nimport { calculateMonthDateIntervals } from '../month-view/computeds';\nimport { calculateAllDayDateIntervals } from '../all-day-panel/computeds';\n\nexport const allDayRects: AllDayRects = (\n  appointments, startViewDate, endViewDate,\n  excludedDays, viewCellsData, cellElementsMeta,\n) => {\n  const intervals = calculateAllDayDateIntervals(\n    appointments, startViewDate, endViewDate, excludedDays,\n  );\n  return calculateRectByDateIntervals(\n    {\n      growDirection: HORIZONTAL_TYPE,\n      multiline: false,\n    },\n    intervals,\n    getHorizontalRectByDates,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellElementsMeta,\n      excludedDays,\n    },\n  );\n};\n\nexport const verticalTimeTableRects: VerticalRects = (\n  appointments, startViewDate, endViewDate, excludedDays,\n  viewCellsData, cellDuration, cellElementsMeta,\n) => {\n  const intervals = calculateWeekDateIntervals(\n    appointments, startViewDate, endViewDate, excludedDays, cellDuration,\n  );\n  return calculateRectByDateIntervals(\n    {\n      growDirection: VERTICAL_TYPE,\n      multiline: false,\n    },\n    intervals,\n    getVerticalRectByDates,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellDuration,\n      cellElementsMeta,\n    },\n  );\n};\n\nexport const horizontalTimeTableRects: HorizontalRects = (\n  appointments, startViewDate, endViewDate,\n  viewCellsData, cellElementsMeta,\n) => {\n  const intervals = calculateMonthDateIntervals(\n    appointments, startViewDate, endViewDate,\n  );\n  return calculateRectByDateIntervals(\n    {\n      growDirection: HORIZONTAL_TYPE,\n      multiline: true,\n    },\n    intervals,\n    getHorizontalRectByDates,\n    {\n      startViewDate,\n      endViewDate,\n      viewCellsData,\n      cellElementsMeta,\n    },\n  );\n};\n","import { DateTimeFormatInstanceFn } from '../../types';\n\nexport const dateTimeFormatInstance: DateTimeFormatInstanceFn = (\n  locale, formatOptions,\n) => new Intl.DateTimeFormat(locale, formatOptions);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { AppointmentModel, Appointment, FormatDateTimeGetterFn, FormatterFn } from '../../types';\nimport { dateTimeFormatInstance } from './helpers';\n\nexport const appointments: PureComputed<\n  [AppointmentModel[]], Appointment[]\n> = data => data.map(appointment => ({\n  dataItem: appointment,\n  start: appointment.startDate,\n  ...appointment.endDate !== undefined ? {\n    end: appointment.endDate,\n  } : {\n    end: appointment.startDate,\n    dataItem: { ...appointment, endDate: appointment.startDate },\n  },\n  ...appointment.allDay !== undefined && {\n    allDay: appointment.allDay,\n  },\n  ...appointment.rRule !== undefined && {\n    rRule: appointment.rRule,\n  },\n  ...appointment.exDate !== undefined && {\n    exDate: appointment.exDate,\n  },\n}));\n\nexport const formatDateTimeGetter: FormatDateTimeGetterFn = (locale) => {\n  const cache = new Map<Intl.DateTimeFormatOptions, Intl.DateTimeFormat>(); // any -> type\n\n  const formatter: FormatterFn = (nextDate, nextOptions) => {\n    if (nextDate === undefined) return '';\n    const date = new Date(nextDate);\n    let formatInstance = cache.get(nextOptions);\n\n    if (!formatInstance) {\n      formatInstance = dateTimeFormatInstance(locale, nextOptions);\n      cache.set(nextOptions, formatInstance);\n    }\n\n    return formatInstance.format(date);\n  };\n  return formatter;\n};\n","import moment from 'moment';\nimport { PureReducer } from '@devexpress/dx-core';\nimport { ChangeCurrentDatePayload } from '../../types';\n\nexport const changeCurrentDate: PureReducer<Date, ChangeCurrentDatePayload> = (\n  currentDate, {\n  nextDate, step, amount, direction,\n}) => (\n  nextDate\n  || moment(currentDate as Date)[direction === 'back' ? 'subtract' : 'add'](amount, step)\n    .toDate()\n  || moment().subtract(amount, step)\n);\n\nexport const setCurrentViewName: PureReducer<\n  string, string, string\n> = (currentViewName, nextViewName) => nextViewName;\n","import { PureReducer } from '@devexpress/dx-core';\nimport { AppointmentMeta } from '../../types';\n\nexport const setAppointmentMeta: PureReducer<AppointmentMeta, AppointmentMeta> = (\n  prevAppointmentMeta,\n  { target, data },\n) => ({ target, data });\n","export const OPEN_COMMAND_BUTTON = 'open';\nexport const CLOSE_COMMAND_BUTTON = 'close';\nexport const DELETE_COMMAND_BUTTON = 'delete';\nexport const CANCEL_COMMAND_BUTTON = 'cancel';\nexport const COMMIT_COMMAND_BUTTON = 'commit';\n","import { PureReducer } from '@devexpress/dx-core';\nimport { AppointmentModel, AppointmentDataPayload } from '../../types';\n\nexport const setAppointmentData: PureReducer<\n  AppointmentModel, AppointmentDataPayload\n> = (prevAppointmentData, { appointmentData }) => appointmentData;\n","import { RRule } from 'rrule';\n\nexport const DEFAULT_RULE_OBJECT = {\n  interval: 1,\n};\n\nexport const DAYS_OF_WEEK = {\n  MONDAY: 0,\n  TUESDAY: 1,\n  WEDNESDAY: 2,\n  THURSDAY: 3,\n  FRIDAY: 4,\n  SATURDAY: 5,\n  SUNDAY: 6,\n};\n\nexport const DAYS_IN_WEEK = 7;\n\nexport const DAYS_OF_WEEK_ARRAY = [\n  DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY,\n  DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY,\n];\n\nexport const MONTHS = {\n  JANUARY: 1,\n  FEBRUARY: 2,\n  MARCH: 3,\n  APRIL: 4,\n  MAY: 5,\n  JUNE: 6,\n  JULY: 7,\n  AUGUST: 8,\n  SEPTEMBER: 9,\n  OCTOBER: 10,\n  NOVEMBER: 11,\n  DECEMBER: 12,\n};\n\nexport const RRULE_REPEAT_TYPES = {\n  YEARLY: RRule.YEARLY as number,\n  MONTHLY: RRule.MONTHLY as number,\n  WEEKLY: RRule.WEEKLY as number,\n  DAILY: RRule.DAILY as number,\n  HOURLY: RRule.HOURLY as number,\n  MINUTELY: RRule.MINUTELY as number,\n};\n\nexport const REPEAT_TYPES = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n  NEVER: 'never',\n};\n\nexport const REPEAT_TYPES_ARRAY = [\n  REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY,\n];\n\nexport const WEEK_NUMBER_LABELS = [\n  'firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel',\n];\n\nexport const END_REPEAT_RADIO_GROUP = 'endRepeat';\nexport const MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';\nexport const YEARLY_RADIO_GROUP = 'yearlyRadioGroup';\n\nexport const TITLE_TEXT_EDITOR = 'titleTextEditor';\nexport const MULTILINE_TEXT_EDITOR = 'multilineTextEditor';\nexport const ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';\nexport const NUMBER_EDITOR = 'numberEditor';\n\nexport const TITLE = 'title';\nexport const ORDINARY_LABEL = 'ordinaryLabel';\n\nexport const SAVE_BUTTON = 'saveButton';\nexport const DELETE_BUTTON = 'deleteButton';\nexport const CANCEL_BUTTON = 'cancelButton';\n\nexport const OUTLINED_SELECT = 'outlinedSelect';\nexport const STANDARD_SELECT = 'standardSelect';\n\nexport const SUNDAY_DATE = new Date(2019, 7, 11);\nexport const MONDAY_DATE = new Date(2019, 7, 12);\nexport const TUESDAY_DATE = new Date(2019, 7, 13);\nexport const WEDNESDAY_DATE = new Date(2019, 7, 14);\nexport const THURSDAY_DATE = new Date(2019, 7, 15);\nexport const FRIDAY_DATE = new Date(2019, 7, 16);\nexport const SATURDAY_DATE = new Date(2019, 7, 17);\n\nexport const DAYS_OF_WEEK_DATES = [\n  SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE,\n  THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE,\n];\n\nexport const JANUARY_DATE = new Date(2019, 0, 1);\nexport const FEBRUARY_DATE = new Date(2019, 1, 1);\nexport const MARCH_DATE = new Date(2019, 2, 1);\nexport const APRIL_DATE = new Date(2019, 3, 1);\nexport const MAY_DATE = new Date(2019, 4, 1);\nexport const JUNE_DATE = new Date(2019, 5, 1);\nexport const JULY_DATE = new Date(2019, 6, 1);\nexport const AUGUST_DATE = new Date(2019, 7, 1);\nexport const SEPTEMBER_DATE = new Date(2019, 8, 1);\nexport const OCTOBER_DATE = new Date(2019, 9, 1);\nexport const NOVEMBER_DATE = new Date(2019, 10, 1);\nexport const DECEMBER_DATE = new Date(2019, 11, 1);\n\nexport const MONTHS_DATES = [\n  JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE,\n  JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE,\n];\n\nexport const FIRST_WEEK = 0;\nexport const SECOND_WEEK = 1;\nexport const THIRD_WEEK = 2;\nexport const FOURTH_WEEK = 3;\nexport const LAST_WEEK = 4;\n\nexport const BASIC_YEALY_COUNT = 5;\nexport const BASIC_MONTHLY_COUNT = 12;\nexport const BASIC_WEEKLY_COUNT = 13;\nexport const BASIC_DAILY_COUNT = 30;\n","import {\n  LONG_WEEK_DAY_OPTIONS, DAY_LONG_MONTH_OPTIONS,\n  LONG_MONTH_OPTIONS,\n} from '@devexpress/dx-scheduler-core';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { Option, OptionsFormatterFn, DateFormatterFn, RecurrenceFrequency } from '../../types';\nimport {\n  MONTHS_DATES, REPEAT_TYPES_ARRAY, WEEK_NUMBER_LABELS, DAYS_IN_WEEK, RRULE_REPEAT_TYPES,\n  BASIC_YEALY_COUNT, BASIC_MONTHLY_COUNT, BASIC_WEEKLY_COUNT, BASIC_DAILY_COUNT,\n} from './constants';\nimport { getDaysOfWeekDates, getDaysOfWeekArray } from './helpers';\n\nexport const getWeekNumberLabels: OptionsFormatterFn = getMessage =>\n  WEEK_NUMBER_LABELS.map((weekNumberLabel, index) => ({\n    text: getMessage(weekNumberLabel),\n    id: index,\n  }));\n\nexport const getDaysOfWeek: PureComputed<\n  [(date: Date, formatOptions: object) => string, number], Array<Option>\n> = (formatDate, firstDayOfWeek) => {\n  const daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);\n  const daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);\n  return daysOfWeekDates.map(\n    (day, index) => ({\n      text: getDayOfWeek(day, formatDate),\n      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0],\n    }),\n  );\n};\n\nexport const getMonths: DateFormatterFn = formatDate => MONTHS_DATES.map((month, index) => ({\n  text: getMonth(month, formatDate),\n  id: getMonthId(index),\n}));\n\nexport const getMonthsWithOf: PureComputed<\n  [(messageKey: string) => string, (date: Date, formatOptions: object) => string],\n    Array<Option>\n> = (getMessage, formatDate) => MONTHS_DATES.map((month, index) => ({\n  text: getMonthWithOf(month, getMessage, formatDate),\n  id: getMonthId(index),\n}));\n\nconst getMonthWithOf = (\n  date: Date,\n  getMessage: (messageKey: string) => string,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => getMessage('ofLabel')\n  + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\\d.,]/g, '').toString();\n\nconst getMonth = (\n  date: Date,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => formatDate(date, LONG_MONTH_OPTIONS);\n\nconst getDayOfWeek = (\n  date: Date,\n  formatDate: (date: Date, formatOptions: object) => string,\n) => formatDate(date, LONG_WEEK_DAY_OPTIONS);\n\nconst getMonthId: PureComputed<\n  [number], number\n> = index => index + 1;\n\nexport const getAvailableRecurrenceOptions: OptionsFormatterFn = getMessage =>\n  REPEAT_TYPES_ARRAY.map(type => ({\n    text: getMessage(type),\n    id: type,\n  }));\n\nexport const getCountDependingOnRecurrenceType = (frequency: RecurrenceFrequency) => {\n  let count;\n  switch (frequency) {\n    case RRULE_REPEAT_TYPES.YEARLY:\n      count = BASIC_YEALY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.MONTHLY:\n      count = BASIC_MONTHLY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.WEEKLY:\n      count = BASIC_WEEKLY_COUNT;\n      break;\n    case RRULE_REPEAT_TYPES.DAILY:\n      count = BASIC_DAILY_COUNT;\n      break;\n  }\n  return count;\n};\n\nexport const checkIsNaturalNumber: PureComputed<\n  [number], boolean\n> = number => number > 0 && number <= Number.MAX_SAFE_INTEGER;\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { RRule, Options, Weekday } from 'rrule';\nimport {\n  Action,\n  StartDate,\n  EndDate,\n  RadioGroupDisplayData,\n} from '../../types';\nimport {\n  DEFAULT_RULE_OBJECT, RRULE_REPEAT_TYPES, REPEAT_TYPES, LAST_WEEK,\n  DAYS_OF_WEEK_ARRAY, DAYS_IN_WEEK, DAYS_OF_WEEK_DATES,\n} from './constants';\nimport { getCountDependingOnRecurrenceType } from './utils';\n\nexport const callActionIfExists: PureComputed<[Action, object], void> = (action, payload) => {\n  if (action) {\n    action(payload);\n  }\n};\n\nexport const isAllDayCell: PureComputed<\n  [StartDate, EndDate], boolean\n> = (\n  startDate, endDate,\n  ) => moment(endDate as EndDate).diff(moment(startDate as StartDate), 'days') >= 1;\n\nexport const changeRecurrenceFrequency: PureComputed<\n  [string, number, Date], string\n> = (\n  rule, freq, startDate,\n) => {\n  if (!rule) {\n    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {\n      return (new RRule({\n        ...DEFAULT_RULE_OBJECT,\n        freq,\n        bymonthday: [startDate.getDate()],\n        count: getCountDependingOnRecurrenceType(freq),\n      })).toString();\n    }\n    if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n      return (new RRule({\n        ...DEFAULT_RULE_OBJECT,\n        freq,\n        bymonthday: [startDate.getDate()],\n        bymonth: startDate.getMonth() + 1,\n        count: getCountDependingOnRecurrenceType(freq),\n      })).toString();\n    }\n    return (new RRule({\n      ...DEFAULT_RULE_OBJECT, freq, count: getCountDependingOnRecurrenceType(freq),\n    })).toString();\n  }\n\n  const options = RRule.parseString(rule);\n  if (options.freq === freq) return rule;\n\n  options.freq = freq;\n  options.count = getCountDependingOnRecurrenceType(freq);\n  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonthday = startDate.getDate();\n  }\n  if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonth = startDate.getMonth() + 1;\n  }\n  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {\n    options.bymonthday = undefined;\n  }\n  options.byweekday = undefined;\n  const nextRule = new RRule(options);\n  return nextRule.toString();\n};\n\nexport const getRecurrenceOptions: PureComputed<\n  [string | undefined], Partial<Options> | null\n> = (rule) => {\n  if (!rule) return null;\n  const options = RRule.parseString(rule);\n  if (options.byweekday) {\n    const byweekday = (options.byweekday as Weekday[]).map(weekDay => weekDay.weekday);\n    options.byweekday = byweekday;\n  }\n  return options;\n};\n\nexport const changeRecurrenceOptions = (options: Partial<Options>) => {\n  return options ? (new RRule({ ...options })).toString() : undefined;\n};\n\nexport const handleStartDateChange = (nextStartDay: number, options: Partial<Options>) => {\n  if (nextStartDay <= 31) {\n    const nextOptions = { ...options, bymonthday: nextStartDay };\n    return changeRecurrenceOptions(nextOptions);\n  }\n  return changeRecurrenceOptions(options);\n};\n\nexport const handleToDayOfWeekChange = (\n  weekNumber: number, dayOfWeek: number, options: Partial<Options>,\n) => {\n  const nextOptions = setByMonthDay(weekNumber, options);\n  nextOptions.byweekday = dayOfWeek > 0 ? dayOfWeek - 1 : 6;\n  return changeRecurrenceOptions(nextOptions);\n};\n\nexport const handleWeekNumberChange = (nextWeekNumber: number, options: Partial<Options>) =>\n  changeRecurrenceOptions(setByMonthDay(nextWeekNumber, options));\n\nexport const getRRuleFrequency: PureComputed<\n  [string], number\n> = repeatType => RRULE_REPEAT_TYPES[repeatType.toUpperCase()];\n\nexport const getFrequencyString: PureComputed<\n  [number], string\n> = (rRuleFrequency) => {\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY) return REPEAT_TYPES.DAILY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY) return REPEAT_TYPES.WEEKLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY) return REPEAT_TYPES.MONTHLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY) return REPEAT_TYPES.YEARLY;\n  return REPEAT_TYPES.NEVER;\n};\n\nconst setByMonthDay = (nextWeekNumber: number, options: Partial<Options>) => {\n  if (nextWeekNumber < 4) {\n    return {\n      ...options,\n      bymonthday: [\n        nextWeekNumber * 7 + 1,\n        nextWeekNumber * 7 + 2,\n        nextWeekNumber * 7 + 3,\n        nextWeekNumber * 7 + 4,\n        nextWeekNumber * 7 + 5,\n        nextWeekNumber * 7 + 6,\n        nextWeekNumber * 7 + 7,\n      ],\n    };\n  }\n  return { ...options, bymonthday: [-1, -2, -3, -4, -5, -6, -7] };\n};\n\nexport const getRadioGroupDisplayData: PureComputed<\n[Partial<Options>, number, number, number, string, string], RadioGroupDisplayData\n> = (\n  recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption,\n) => {\n  let weekNumber = LAST_WEEK;\n  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {\n    return {\n      dayNumberTextField: (recurrenceOptions.bymonthday as number),\n      weekNumber: stateWeekNumber,\n      dayOfWeek: stateDayOfWeek,\n      radioGroupValue: firstOption,\n    };\n  }\n  if (!recurrenceOptions.byweekday) {\n    return {\n      dayOfWeek: stateDayOfWeek,\n      weekNumber: stateWeekNumber,\n      radioGroupValue: secondOption,\n      dayNumberTextField: stateDayNumber,\n    };\n  }\n  const dayOfWeek = recurrenceOptions.byweekday[0] < 6\n    ? recurrenceOptions.byweekday[0] + 1 : 0;\n  if (recurrenceOptions.bymonthday && (recurrenceOptions.bymonthday[0] > 0)) {\n    weekNumber = Math.trunc(recurrenceOptions.bymonthday[0] / 7);\n  }\n\n  return {\n    dayOfWeek,\n    weekNumber,\n    radioGroupValue: secondOption,\n    dayNumberTextField: stateDayNumber,\n  };\n};\n\nexport const handleChangeFrequency: PureComputed<\n  [string, string, Date, Action], void\n> = (repeatType, rRule, startDate, action) => {\n  const rruleRepeatType = getRRuleFrequency(repeatType);\n  let nextRRule;\n  if (rruleRepeatType !== undefined) {\n    nextRRule = changeRecurrenceFrequency(\n      rRule,\n      rruleRepeatType,\n      startDate,\n    );\n  }\n  action({ rRule: nextRRule });\n};\n\nexport const handleWeekDaysChange: PureComputed<\n[Partial<Options>, number], void\n> = (options, weekDay) => {\n  const byWeekDay = options.byweekday || [];\n  const index = (byWeekDay as number[]).indexOf(weekDay);\n  const isAdded = !(index > -1);\n  if (isAdded) {\n    (byWeekDay as number[]).push(weekDay);\n  } else if (index > -1) {\n    (byWeekDay as number[]).splice(index, 1);\n  }\n  if (byWeekDay === 0) return { ...options, byweekday: undefined };\n  return { ...options, byweekday: byWeekDay };\n};\n\nexport const getDaysOfWeekArray: PureComputed<[number], Array<number>> = (firstDayOfWeek) => {\n  const firstPart = DAYS_OF_WEEK_ARRAY.filter(\n    dayOfWeek => dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1,\n  );\n  const secondPart = DAYS_OF_WEEK_ARRAY.filter(\n    dayOfWeek => dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1,\n  );\n  return firstDayOfWeek !== 0 ? [...firstPart, ...secondPart] : [...secondPart, ...firstPart];\n};\n\nexport const getDaysOfWeekDates: PureComputed<[number], Array<Date>> = (firstDayOfWeek) => {\n  const firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);\n  const secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);\n  return [...firstPart, ...secondPart];\n};\n","import { PureReducer } from '@devexpress/dx-core';\nimport {\n  AddedAppointmentDataPayload, AppointmentModel, Changes, EditAppointmentPayload,\n} from '../../types';\n\nexport const addAppointment: PureReducer<\n  AppointmentModel, AddedAppointmentDataPayload, AppointmentModel | {}\n> = (\n  addedAppointmentData, { appointmentData } = { appointmentData:  {} },\n) => appointmentData;\n\nexport const cancelAddedAppointment = () => ({});\n\nexport const startEditAppointment: PureReducer<\n  Partial<AppointmentModel>, EditAppointmentPayload\n> = (prevEditingAppointment, appointmentData) => appointmentData;\n\nexport const stopEditAppointment = () => undefined;\n\nexport const changeAppointment: PureReducer<\nAppointmentModel, Changes\n> = (\n  appointment, { change },\n) => ({ ...appointment, ...change });\n\nexport const cancelChanges = () => ({});\n","import { PureComputed } from '@devexpress/dx-core';\nimport { AppointmentId, AppointmentChanges, Changes } from '../../types';\n\nexport const changedAppointmentById: PureComputed<\n  [Changes, AppointmentId], AppointmentChanges\n> = (changes, appointmentId) => (\n  { [appointmentId]: changes }\n);\n","import moment from 'moment';\nimport { RRule, RRuleSet } from 'rrule';\nimport {\n  AppointmentModel, PreCommitChangesFn, Changes, MakeDateSequenceFn, EditFn, DeleteFn, ChangeFn,\n} from '../../types';\nimport { RECURRENCE_EDIT_SCOPE } from '../../constants';\nimport { getUTCDate, getRRuleSetWithExDates, formatDateToString } from '../../utils';\n\nconst mergeNewChanges = (\n  appointmentData: Partial<AppointmentModel>, changes: Changes,\n) => {\n  const appointment = {\n    ...appointmentData,\n  };\n  delete appointment.id;\n  delete appointment.rRule;\n  delete appointment.exDate;\n  delete appointment.parentData;\n  return { ...appointment, ...changes };\n};\n\nconst reduceExDate = (prevExDate: string, boundDate: Date) => {\n  if (prevExDate.length > 0) {\n    return prevExDate.split(',').reduce((acc: string[], date: string) => {\n      const momentDate = moment.utc(date);\n      if (momentDate.isBefore(boundDate)) {\n        return [...acc, date];\n      }\n      return acc;\n    }, []).join(',');\n  }\n  return undefined;\n};\n\nconst configureExDate = (exDate: string | undefined, date: Date) => {\n  const currentExDate = `${moment.utc(date).format('YYYYMMDDTHHmmss')}Z`;\n  return exDate\n    ? `${exDate},${currentExDate}`\n    : currentExDate;\n};\n\nconst configureDateSequence: MakeDateSequenceFn = (rRule, exDate, prevStartDate, nextStartDate) => {\n  const rruleSet = getRRuleSetWithExDates(exDate);\n\n  const currentOptions = RRule.parseString(rRule as string);\n  const correctedOptions = currentOptions.until\n    ? { ...currentOptions, until: moment(getUTCDate(currentOptions.until)).toDate() }\n    : currentOptions;\n  const prevStartDateUTC = moment(getUTCDate(prevStartDate!)).toDate();\n  rruleSet.rrule(new RRule({\n    ...correctedOptions,\n    dtstart: prevStartDateUTC,\n  }));\n  if (currentOptions.count || currentOptions.until) {\n    return rruleSet.all()\n      // we shouldn't use `new Date(string)` because this function has different results in Safari\n      .map(nextDate => moment(formatDateToString(nextDate)).toDate());\n  }\n  const leftBound = prevStartDateUTC;\n  const rightBound = moment(getUTCDate(nextStartDate!)).toDate();\n  return rruleSet.between(leftBound, rightBound, true)\n    .map(nextDate => moment(formatDateToString(nextDate)).toDate());\n};\n\nconst configureICalendarRules = (rRule: string | undefined, options: object) => {\n  const rruleSet = new RRuleSet();\n  rruleSet.rrule(new RRule({\n    ...RRule.parseString(rRule as string),\n    ...options,\n  }));\n  return rruleSet.valueOf();\n};\n\nconst changeCurrentAndFollowing: ChangeFn = (appointmentData, changes, changeAllAction) => {\n  const { rRule, startDate, parentData, exDate: prevExDate = '', id } = appointmentData;\n\n  const { initialSequence, currentChildIndex } = getAppointmentSequenceData(\n    parentData.startDate, moment.utc(startDate as Date).toDate(), prevExDate, rRule,\n  );\n\n  if (currentChildIndex === 0) return changeAllAction(appointmentData, changes);\n\n  const changedRules = configureICalendarRules(rRule as string, {\n    dtstart: moment.utc(parentData.startDate).toDate(),\n    until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),\n    count: null,\n  });\n\n  const nextExDate = reduceExDate(prevExDate, startDate as Date);\n  return {\n    changed: {\n      [id!]: {\n        rRule: changedRules[1].slice(6),\n        ...nextExDate && prevExDate !== nextExDate ? { exDate: nextExDate } : {},\n      },\n    },\n  };\n};\n\nconst getAppointmentSequenceData = (\n  prevStartDate: Date, startDate: Date, exDate: string, rRule: string | undefined,\n) => {\n  const initialSequence: Date[] = configureDateSequence(rRule, exDate,\n    moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate(),\n  );\n  const currentChildIndex = initialSequence\n    .findIndex(date => moment(date).isSame(startDate as Date));\n  return { initialSequence, currentChildIndex };\n};\n\nexport const deleteCurrent: DeleteFn = (appointmentData) => {\n  const currentSequence: Date[] = configureDateSequence(\n    appointmentData.rRule, appointmentData.exDate,\n    moment.utc(appointmentData.parentData.startDate).toDate(),\n    moment.utc(appointmentData.startDate).toDate(),\n  );\n\n  if (currentSequence.length === 1) {\n    return deleteAll(appointmentData);\n  }\n\n  const nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate as Date);\n  return { changed: { [appointmentData.id!]: { exDate: nextExDate } } };\n};\n\nexport const deleteAll: DeleteFn = (appointmentData) => {\n  return { deleted: appointmentData.id };\n};\n\nexport const deleteCurrentAndFollowing: DeleteFn = appointmentData => changeCurrentAndFollowing(\n  appointmentData, {}, deleteAll,\n);\n\nexport const editAll: EditFn = (appointmentData, changes) => {\n  const { rRule, id } = appointmentData;\n\n  const initialRule = new RRule(RRule.parseString(rRule as string));\n  if (changes.startDate\n    && moment.utc(changes.startDate as Date).isAfter(initialRule.options.until!)) {\n    return {\n      changed: {\n        [id!]: {\n          ...changes,\n          rRule: 'FREQ=DAILY;COUNT=1',\n          exDate: '',\n        },\n      },\n    };\n  }\n\n  return  { changed: {  [appointmentData.id!]: changes } };\n};\n\nexport const editCurrent: EditFn = (appointmentData, changes) => ({\n  changed: {\n    [appointmentData.id!]: {\n      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate as Date),\n    },\n  },\n  added: mergeNewChanges(appointmentData as Partial<AppointmentModel>, changes as Changes),\n});\n\nexport const editCurrentAndFollowing: EditFn = (appointmentData, changes) => {\n  const { rRule, startDate, exDate: prevExDate = '', parentData } = appointmentData;\n  const initialRule = new RRule(RRule.parseString(rRule as string));\n\n  const { initialSequence, currentChildIndex } = getAppointmentSequenceData(\n    parentData.startDate, moment.utc(startDate as Date).toDate(),  prevExDate, rRule,\n  );\n  if (currentChildIndex === 0) return editAll(appointmentData, changes);\n\n  const addedOptions = initialRule.options.count || initialRule.options.until\n    ? { count: initialSequence.length - currentChildIndex }\n    : {};\n  const addedRules = configureICalendarRules(appointmentData.rRule as string, {\n    dtstart: moment.utc(startDate as Date).toDate(),\n    ...addedOptions,\n  });\n\n  const addedAppointment = moment.utc(changes.startDate as Date).isAfter(initialRule.options.until!)\n    ? { rRule: 'FREQ=DAILY;COUNT=1', exDate: '' } : { rRule: addedRules[1].slice(6) };\n\n  return {\n    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,\n    added: {\n      ...addedAppointment, ...mergeNewChanges(appointmentData, changes),\n    },\n  };\n};\n\nexport const preCommitChanges: PreCommitChangesFn = (\n  changes, appointmentData, editType,\n) => {\n  if (changes === null) {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL: {\n        return deleteAll(appointmentData);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT: {\n        return deleteCurrent(appointmentData);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {\n        return deleteCurrentAndFollowing(appointmentData);\n      }\n    }\n  } else {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL: {\n        return editAll(appointmentData, changes);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT: {\n        return editCurrent(appointmentData, changes);\n      }\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {\n        return editCurrentAndFollowing(appointmentData, changes);\n      }\n    }\n  }\n  return {};\n};\n","import moment from 'moment';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  ViewCell, ClientOffset, TimeType, ScrollingStrategy,\n  AllDayCell, CalculateAppointmentTimeBoundaries,\n  TimeBoundariesByDrag, TimeBoundariesByResize, AppointmentModel,\n  CellElementsMeta,\n} from '../../types';\nimport { allDayCells as allDayCellsCore } from '../common/computeds';\nimport {\n  VERTICAL_TYPE, HORIZONTAL_TYPE, SCROLL_OFFSET, MINUTES,\n  SCROLL_SPEED_PX, SECONDS, RESIZE_TOP, RESIZE_BOTTOM, HOURS,\n} from '../../constants';\nimport {\n  allDayRects, horizontalTimeTableRects, verticalTimeTableRects,\n} from '../common/calculate-rects';\n\nconst clamp: PureComputed<\n  [number, number, number]\n> = (value, min, max) => Math.max(Math.min(value, max), min);\n\nconst calculateInsideOffset: PureComputed<\n  [string, number, number], number\n> = (targetType, insidePart, cellDurationMinutes) => targetType === VERTICAL_TYPE\n  ? insidePart * cellDurationMinutes * 60 / 2 : 0;\n\nexport const cellType: PureComputed<\n  [ViewCell | AllDayCell], string\n> = data => moment(data.startDate as Date)\n  .isSame(data.endDate as Date, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE;\n\nexport const intervalDuration: PureComputed<\n  [ViewCell | AllDayCell, TimeType], number\n> = (data, type) => moment(data.endDate as Date).diff(data.startDate as Date, type);\n\nexport const cellIndex: PureComputed<\n  [Array<() => ClientRect>, ClientOffset], number\n> = (getCellRects, clientOffset) => getCellRects.findIndex((getCellRect) => {\n  const { left, top, right, bottom } = getCellRect();\n  const isOver = clientOffset\n      && clamp(clientOffset.x, left, right) === clientOffset.x\n      && clamp(clientOffset.y, top, bottom) === clientOffset.y;\n  return isOver;\n});\n\nexport const cellData: PureComputed<\n  [number, number, ViewCell[][]], ViewCell | AllDayCell\n> = (timeTableIndex, allDayIndex, viewCellsData) => {\n  if (allDayIndex !== -1) {\n    const allDayCellsData = allDayCellsCore(viewCellsData);\n    return allDayCellsData[allDayIndex];\n  }\n  const firstIndex = Math.floor(timeTableIndex / viewCellsData[0].length);\n  const secondIndex = timeTableIndex % viewCellsData[0].length;\n  return viewCellsData[firstIndex][secondIndex];\n};\n\nexport const autoScroll: PureComputed<\n  [ClientOffset, ScrollingStrategy], void\n> = (clientOffset, scrollingStrategy) => {\n  if ((clientOffset.y < scrollingStrategy.topBoundary + SCROLL_OFFSET)\n    && (clientOffset.y > scrollingStrategy.topBoundary)) {\n    scrollingStrategy.changeVerticalScroll(-SCROLL_SPEED_PX);\n  }\n  if (scrollingStrategy.bottomBoundary - SCROLL_OFFSET < clientOffset.y) {\n    scrollingStrategy.changeVerticalScroll(+SCROLL_SPEED_PX);\n  }\n};\n\nexport const timeBoundariesByResize: TimeBoundariesByResize = (\n  payload, targetData, targetType, cellDurationMinutes, insidePart,\n) => {\n  if (targetType !== payload.appointmentType) {\n    return { appointmentStartTime: undefined, appointmentEndTime: undefined };\n  }\n\n  let appointmentStartTime;\n  let appointmentEndTime;\n  const sourceType = payload.type;\n\n  if (sourceType === RESIZE_TOP) {\n    const insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n    appointmentStartTime = moment(targetData.startDate as Date)\n      .add(insideTopOffset, SECONDS).toDate();\n    appointmentEndTime = moment(payload.endDate as Date).toDate();\n  }\n  if (sourceType === RESIZE_BOTTOM) {\n    const insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE\n      ? cellDurationMinutes * 60 / 2 : 0;\n    appointmentEndTime = moment(targetData.endDate as Date)\n      .add(-insideBottomOffset, SECONDS).toDate();\n    appointmentStartTime = moment(payload.startDate as Date).toDate();\n  }\n  // keep origin appointment duration if coordinates are wrong\n  if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {\n    appointmentStartTime = moment(payload.startDate as Date).toDate();\n    appointmentEndTime = moment(payload.endDate as Date).toDate();\n  }\n  return { appointmentStartTime, appointmentEndTime };\n};\n\nexport const timeBoundariesByDrag: TimeBoundariesByDrag = (\n  payload, targetData, targetType,\n  cellDurationMinutes, insidePart, offsetTimeTopBase,\n) => {\n  if (targetType === HORIZONTAL_TYPE\n    && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {\n    return {\n      appointmentStartTime: targetData.startDate as Date,\n      appointmentEndTime: targetData.endDate as Date,\n      offsetTimeTop: 0,\n    };\n  }\n  let offsetTimeTop;\n  let appointmentStartTime;\n  let appointmentEndTime;\n\n  const insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n  const start = moment(targetData.startDate as Date).add(insideOffset, SECONDS);\n\n  if (offsetTimeTopBase === null) {\n    offsetTimeTop = moment(targetData.startDate as Date)\n      .diff(payload.startDate as Date, SECONDS) + insideOffset;\n  } else {\n    offsetTimeTop = offsetTimeTopBase;\n  }\n\n  if (payload.type === targetType) {\n    const appointmentDurationSeconds = intervalDuration(payload, SECONDS);\n    appointmentStartTime = moment(start).add((offsetTimeTop) * (-1), SECONDS).toDate();\n    appointmentEndTime = moment(start)\n      .add((appointmentDurationSeconds - offsetTimeTop), SECONDS).toDate();\n  } else {\n    appointmentStartTime = moment(targetData.startDate as Date)\n      .add(insideOffset, SECONDS).toDate();\n    appointmentEndTime = moment(targetData.endDate as Date).add(insideOffset, SECONDS).toDate();\n  }\n\n  return { appointmentStartTime, appointmentEndTime, offsetTimeTop };\n};\n\nexport const calculateAppointmentTimeBoundaries: CalculateAppointmentTimeBoundaries = (\n  payload, targetData, targetType,\n  cellDurationMinutes, insidePart, offsetTimeTopBase,\n) => {\n  const isDragging = (payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE);\n\n  return(isDragging\n    ? timeBoundariesByDrag(\n        payload, targetData as AppointmentModel, targetType,\n        cellDurationMinutes, insidePart, offsetTimeTopBase,\n      )\n    : timeBoundariesByResize(\n        payload, targetData as AppointmentModel, targetType, cellDurationMinutes, insidePart,\n      )\n  );\n};\n\nexport const calculateInsidePart: PureComputed<\n  [number, Array<() => ClientRect>, number]\n> = (top, timeTableCellsRects, timeTableIndex) => {\n  if (timeTableIndex !== undefined && timeTableIndex !== -1) {\n    const cellRect = timeTableCellsRects[timeTableIndex]();\n    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;\n  }\n  return 0;\n};\n\nexport const calculateDraftAppointments = (\n  allDayIndex: number, draftAppointments: any, startViewDate: Date,\n  endViewDate: Date, excludedDays: number[], viewCellsData: any,\n  getAllDayCellsElementRects: CellElementsMeta,\n  targetType: string, cellDurationMinutes: number,\n  getTableCellElementRects: CellElementsMeta,\n) => {\n  if (allDayIndex !== -1 || (targetType === VERTICAL_TYPE\n    && getAllDayCellsElementRects.getCellRects.length\n    && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23)) {\n    const allDayDrafts = draftAppointments.map((draftAppt: any) => ({\n      ...draftAppt,\n      allDay: true,\n    }));\n\n    return {\n      allDayDraftAppointments: allDayRects(\n        allDayDrafts, startViewDate, endViewDate,\n        excludedDays, viewCellsData, getAllDayCellsElementRects,\n      ),\n      timeTableDraftAppointments: [],\n    };\n  }\n\n  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {\n    return {\n      allDayDraftAppointments: [],\n      timeTableDraftAppointments: verticalTimeTableRects(\n        draftAppointments, startViewDate, endViewDate,\n        excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects,\n      ),\n    };\n  }\n  return {\n    allDayDraftAppointments: [],\n    timeTableDraftAppointments: horizontalTimeTableRects(\n      draftAppointments, startViewDate, endViewDate,\n      viewCellsData, getTableCellElementRects,\n    ),\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport moment from 'moment';\nimport {\n  IsCellShadedFn, IsShadedAppointment,\n  GetCurrentTimeIndicatorTopFn,\n} from '../../types';\n\nexport const isMonthCell: PureComputed<\n  [boolean | undefined], boolean\n> = otherMonth => otherMonth !== undefined;\n\nexport const isShadedAppointment: IsShadedAppointment = (\n  { data: appointmentData }, currentTime, shadePreviousAppointments,\n) => {\n  const momentCurrentDate = moment(currentTime);\n  if (appointmentData.allDay) {\n    return momentCurrentDate.isAfter(appointmentData.endDate as Date, 'day')\n    && shadePreviousAppointments;\n  }\n  if (momentCurrentDate.isAfter(appointmentData.endDate as Date)) {\n    return shadePreviousAppointments;\n  }\n  return false;\n};\n\nexport const getCurrentTimeIndicatorTop: GetCurrentTimeIndicatorTopFn = (\n  cellData, currentTime,\n) => {\n  const top = ((currentTime - cellData.startDate.getTime()) * 100)\n  / (cellData.endDate.getTime() - cellData.startDate.getTime());\n  return (top < 0 || top > 100) ? undefined : `${top}%`;\n};\n\nexport const isCellShaded: IsCellShadedFn = (\n  { startDate, endDate, otherMonth }, currentTime, shadePreviousCells,\n) => {\n  const monthCell = isMonthCell(otherMonth);\n  return ((startDate.getTime() < currentTime && !monthCell)\n    || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;\n};\n","import {\n  ConvertResourcesToPlain, ValidateResources, ValidResourceInstance,\n} from '../../types';\n\nexport const convertResourcesToPlain: ConvertResourcesToPlain = (validResources) => {\n  return validResources.reduce((acc, resource) => [\n    ...acc,\n    ...resource.instances.map(item => item),\n  ], [] as Array<ValidResourceInstance>);\n};\n\nexport const validateResources: ValidateResources = (resources, mainResourceName, palette) => {\n  const isMainResourceDefined = !!mainResourceName;\n  let currentPaletteIndex = 0;\n  return resources.map((resource, groupIndex) => {\n    const fieldName = resource.fieldName;\n    const isMain = isMainResourceDefined && mainResourceName === fieldName\n      || groupIndex === 0 && !isMainResourceDefined;\n    const title = resource.title || fieldName;\n    const allowMultiple = !!resource.allowMultiple;\n    return {\n      fieldName,\n      isMain,\n      title,\n      allowMultiple,\n      instances: resource.instances.map((resourceItem) => {\n        const color = resourceItem.color || palette[currentPaletteIndex];\n        if (!resourceItem.color) currentPaletteIndex += 1;\n\n        return ({\n          id: resourceItem.id,\n          color,\n          fieldName,\n          text: resourceItem.text || title || fieldName,\n          title,\n          allowMultiple,\n          isMain,\n        });\n      }),\n    };\n  });\n};\n","import { GetAppointmentResources, ValidResourceInstance } from '../../types';\n\nexport const getAppointmentResources: GetAppointmentResources = (\n  appointment, resources, plainResources,\n) => {\n  if (\n    !resources || resources.length === 0\n    || !plainResources || plainResources.length === 0\n  ) return [];\n\n  return resources.reduce((acc, resource) => {\n    const appointmentResourceId = appointment[resource.fieldName];\n    if (appointmentResourceId === undefined) return acc;\n\n    if (resource.allowMultiple && !Array.isArray(appointmentResourceId)\n    || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {\n      // throw error\n      return acc;\n    }\n\n    if (resource.allowMultiple) {\n      return [\n        ...acc,\n        ...(appointmentResourceId as Array<number | string>).map(itemId => plainResources.find(\n          plainItem => resource.fieldName === plainItem.fieldName && plainItem.id === itemId),\n        ),\n      ];\n    }\n\n    return [\n      ...acc,\n      ...(plainResources as Array<any>).find(plainItem =>\n        resource.fieldName === plainItem.fieldName && plainItem.id === appointmentResourceId,\n      ),\n    ];\n  }, [] as Array<ValidResourceInstance>);\n};\n","import { AppointmentModel, SchedulerDateTime } from './scheduler-core.types';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { RRULE_REPEAT_TYPES } from '../plugins/appointment-form/constants';\n\n/** @internal */\nexport type Action = ([fieldName]?: any) => void;\n/** @internal */\nexport type StartDate = SchedulerDateTime;\n/** @internal */\nexport type EndDate = SchedulerDateTime;\n/** @internal */\nexport type AppointmentDataPayload = {\n  appointmentData: AppointmentModel;\n};\n/** @internal */\nexport type AddedAppointmentDataPayload = {\n  appointmentData: AppointmentModel | {};\n};\n/** @internal */\nexport type RadioGroupDisplayData = {\n  weekNumber: number;\n  dayNumberTextField: number;\n  dayOfWeek: number;\n  radioGroupValue: string;\n};\n/** @internal */\nexport type Option = {\n  text: string;\n  id: number | string;\n};\n/** @internal */\nexport type OptionsFormatterFn = PureComputed<\n  [(messageKey: string) => string], Array<Option>\n>;\n/** @internal */\nexport type DateFormatterFn = PureComputed<\n  [(date: Date, formatOptions: object) => string], Array<Option>\n>;\n/** @internal */\nexport enum RecurrenceFrequency {\n  Daily = RRULE_REPEAT_TYPES.DAILY,\n  Weekly = RRULE_REPEAT_TYPES.WEEKLY,\n  Monthly = RRULE_REPEAT_TYPES.MONTHLY,\n  Yearly = RRULE_REPEAT_TYPES.YEARLY,\n}\n"]},"metadata":{},"sourceType":"module"}