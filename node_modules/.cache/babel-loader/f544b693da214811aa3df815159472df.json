{"ast":null,"code":"import { isPresent, isNullOrEmptyString, capitalize } from '../../utils';\nimport { parseRule } from '@progress/kendo-recurrence';\nimport { toLocalDate } from '@progress/kendo-date-math';\n/** @hidden */\n\nexport var OFFSET_POSITIONS = ['first', 'second', 'third', 'fourth', 'last'];\n/** @hidden */\n\nexport var FREQUENCIES = ['never', 'daily', 'weekly', 'monthly', 'yearly'];\n/** @hidden */\n\nexport var dayRule = [{\n  day: 0,\n  offset: 0\n}, {\n  day: 1,\n  offset: 0\n}, {\n  day: 2,\n  offset: 0\n}, {\n  day: 3,\n  offset: 0\n}, {\n  day: 4,\n  offset: 0\n}, {\n  day: 5,\n  offset: 0\n}, {\n  day: 6,\n  offset: 0\n}];\n/** @hidden */\n\nexport var weekdayRule = [{\n  day: 1,\n  offset: 0\n}, {\n  day: 2,\n  offset: 0\n}, {\n  day: 3,\n  offset: 0\n}, {\n  day: 4,\n  offset: 0\n}, {\n  day: 5,\n  offset: 0\n}];\n/** @hidden */\n\nexport var weekendRule = [{\n  day: 0,\n  offset: 0\n}, {\n  day: 6,\n  offset: 0\n}];\n/** @hidden */\n\nexport var weekDayRuleFromString = function (weekDay) {\n  switch (weekDay) {\n    case 'day':\n      return dayRule;\n\n    case 'weekday':\n      return weekdayRule;\n\n    case 'weekend':\n      return weekendRule;\n\n    default:\n      break;\n  }\n\n  return;\n};\n/** @hidden */\n\nexport var parseRRule = function (recurrenceRule) {\n  return parseRule({\n    recurrenceRule: recurrenceRule\n  }) || {};\n};\n/** @hidden */\n\nexport var getFrequencies = function (localizeMessage) {\n  return FREQUENCIES.map(function (freq) {\n    return {\n      value: freq,\n      text: localizeMessage('Frequencies' + capitalize(freq))\n    };\n  });\n};\n/** @hidden */\n\nexport var getFrequency = function (rrule) {\n  if (isPresent(rrule) && !isNullOrEmptyString(rrule.freq)) {\n    return rrule.freq;\n  }\n\n  return 'never';\n};\n/** @hidden */\n\nexport var getUntil = function (rrule) {\n  if (isPresent(rrule.until)) {\n    return toLocalDate(rrule.until);\n  }\n\n  return null;\n};\n/** @hidden */\n\nexport var getMonths = function (intl) {\n  return intl.dateFormatNames({\n    type: 'months',\n    nameType: 'wide'\n  }).map(function (month, idx) {\n    return {\n      text: month,\n      value: idx + 1\n    };\n  });\n};\n/** @hidden */\n\nexport var getWeekDays = function (intl) {\n  var firstDay = intl.firstDay();\n  var abbrNames = intl.dateFormatNames({\n    type: 'days',\n    nameType: 'abbreviated'\n  }).map(function (day, idx) {\n    return {\n      text: day,\n      value: idx\n    };\n  });\n  /* Sorting according to first week day */\n\n  return abbrNames.slice(firstDay).concat(abbrNames.slice(0, firstDay));\n};\n/** @hidden */\n\nexport var getExtendedWeekDays = function (intl, localizeMessage) {\n  var firstDay = intl.firstDay();\n  var wideNames = intl.dateFormatNames({\n    type: 'days',\n    nameType: 'wide'\n  }).map(function (day, idx) {\n    return {\n      text: day,\n      value: idx\n    };\n  });\n  var sortedWideNames = wideNames.slice(firstDay).concat(wideNames.slice(0, firstDay));\n  var specialRules = [{\n    text: localizeMessage('WeekdaysDay'),\n    value: 'day'\n  }, {\n    text: localizeMessage('WeekdaysWeekday'),\n    value: 'weekday'\n  }, {\n    text: localizeMessage('WeekdaysWeekendday'),\n    value: 'weekend'\n  }];\n  return specialRules.concat(sortedWideNames);\n};\n/** @hidden */\n\nexport var getOffsetPositions = function (localizeMessage) {\n  var values = [1, 2, 3, 4, -1];\n  return OFFSET_POSITIONS.map(function (offset, idx) {\n    return {\n      text: localizeMessage('OffsetPositions' + capitalize(offset)),\n      value: values[idx]\n    };\n  });\n};\n/** @hidden */\n\nexport var getEndRule = function (rrule) {\n  if (isPresent(rrule.count)) {\n    return 'count';\n  } else if (isPresent(rrule.until)) {\n    return 'until';\n  } else {\n    return 'never';\n  }\n};\n/** @hidden */\n\nexport var getRepeatOnRule = function (rrule) {\n  if (isPresent(rrule.byWeekDay)) {\n    return 'weekday';\n  } else if (isPresent(rrule.byMonthDay)) {\n    return 'monthday';\n  }\n};\n/** @hidden */\n\nexport var getMonthDay = function (rrule, start) {\n  if (isPresent(rrule.byMonthDay) && rrule.byMonthDay.length > 0) {\n    return rrule.byMonthDay[0];\n  } else {\n    return start.getDate();\n  }\n};\n/** @hidden */\n\nexport var getUntilEnd = function (start, until) {\n  var currentStart = start;\n  var currentUntil = until;\n\n  if (isPresent(currentUntil)) {\n    return currentUntil;\n  } else {\n    return new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate(), 23, 59, 59);\n  }\n};\n/** @hidden */\n\nexport var getUntilMin = function (start, until) {\n  var currentStart = start;\n  var currentUntil = until;\n\n  if (isPresent(currentUntil) && currentUntil < currentStart) {\n    return currentUntil;\n  } else {\n    return currentStart;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}