{"ast":null,"code":"import * as React from 'react';\nimport Draggable from '@telerik/kendo-draggable';\nimport { clone } from '@progress/kendo-react-common';\nimport { SchedulerContext } from '../context';\nimport { getRect } from '../views/common/utils';\nimport { generateGroups, slotDive, generateResourceFields, setField } from '../utils';\n/** @hidden */\n\nexport var useDraggable = function (ref, props, args, condition, inputs) {\n  if (inputs === void 0) {\n    inputs = [];\n  }\n\n  var oldSlotRef = React.useRef(null);\n\n  var _a = React.useContext(SchedulerContext),\n      group = _a.group,\n      resources = _a.resources,\n      fields = _a.fields;\n\n  var _b = React.useState(null),\n      dragItem = _b[0],\n      setDragItem = _b[1];\n\n  var initialXRef = React.useRef(null);\n  var initialYRef = React.useRef(null);\n\n  var handlePress = function (element, event) {\n    if (args.onPress) {\n      args.onPress();\n    }\n\n    element.style.userSelect = 'none';\n    var slot = slotDive(event.clientX, event.clientY, 4);\n    initialXRef.current = event.clientX;\n    initialYRef.current = event.clientY;\n\n    if (!slot) {\n      return;\n    }\n\n    var start = slot.getAttribute('data-slot-start');\n    var end = slot.getAttribute('data-slot-end');\n    var distance = Number(end) - Number(start);\n    var eventRect = getRect(element);\n    var size = args.vertical ? eventRect.height : eventRect.width;\n    var part = size / props.slots.length;\n    var offsetPart = args.vertical ? event.offsetY : event.offsetX;\n    var section = Math.floor(offsetPart / part);\n    var offset = args.snapToSlot ? distance * section : Number(start) - props.start.getTime();\n    element.setAttribute('data-offset', String(offset));\n  };\n\n  var handleDrag = function (element, event) {\n    if (!document) {\n      return;\n    }\n\n    element.style.pointerEvents = 'none';\n    var slot = slotDive(event.clientX, event.clientY, 4);\n\n    if (!slot) {\n      return;\n    }\n\n    if (slot === oldSlotRef.current) {\n      return;\n    }\n\n    if (initialXRef.current === event.clientX && initialYRef.current === event.clientY) {\n      return;\n    }\n\n    var isAllDay = slot.getAttribute('data-slot-allday') === 'true';\n    var slotStart = slot.getAttribute('data-slot-start');\n    var slotGroupIndex = slot.getAttribute('data-slot-group');\n\n    if (slotStart === null) {\n      return;\n    }\n\n    if (!args.ignoreIsAllDay && isAllDay !== props.isAllDay) {\n      return;\n    }\n\n    var offset = element.getAttribute('data-offset') || 0;\n    var groupIndex = element.getAttribute('data-group-index');\n    var duration = props.end.getTime() - props.start.getTime();\n    var groups = generateGroups(groupIndex, slotGroupIndex, props.groups, group, resources);\n    var resourceFields = generateResourceFields(groups, props.resourceFields);\n    var start = new Date(Number(slotStart) - Number(offset));\n    var end = new Date(Number(slotStart) - Number(offset) + duration);\n    var item = clone(props._dataItem);\n    setField(item, fields.start, start);\n    setField(item, fields.end, end);\n    Object.keys(resourceFields).forEach(function (key) {\n      if (resourceFields.hasOwnProperty(key)) {\n        setField(item, fields[key] || key, resourceFields[key]);\n      }\n    });\n    oldSlotRef.current = slot;\n    setDragItem(item);\n  };\n\n  var handleRelease = function (element, event) {\n    var newDrag;\n    oldSlotRef.current = null;\n    initialXRef.current = null;\n    initialYRef.current = null;\n    element.style.userSelect = 'auto';\n    element.style.pointerEvents = 'auto';\n    setDragItem(function (current) {\n      newDrag = current;\n      return null;\n    });\n\n    if (!newDrag) {\n      return;\n    }\n\n    if (args.onDrop) {\n      args.onDrop(newDrag, event);\n    }\n  };\n\n  var initDraggable = function () {\n    if (!condition) {\n      return;\n    }\n\n    var elements = ref.current;\n    oldSlotRef.current = null;\n\n    if (!elements || elements.length === 0) {\n      return;\n    }\n\n    var draggables = [];\n    elements.forEach(function (element) {\n      if (element === null) {\n        return;\n      }\n\n      var draggable = new Draggable({\n        press: handlePress.bind(undefined, element),\n        drag: handleDrag.bind(undefined, element),\n        release: handleRelease.bind(undefined, element)\n      });\n      draggable.bindTo(element);\n      draggables.push(draggable);\n    });\n    return function () {\n      draggables.forEach(function (draggable) {\n        return draggable.destroy();\n      });\n    };\n  };\n\n  React.useEffect(initDraggable, [props.ref, condition, props.start.getTime(), props.end.getTime()].concat(inputs));\n  return dragItem;\n};","map":null,"metadata":{},"sourceType":"module"}