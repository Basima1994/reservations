{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { intersects } from '../utils';\nimport { ZonedDate, MS_PER_MINUTE } from '@progress/kendo-date-math';\nimport { orderBy } from '@progress/kendo-data-query';\nimport { generateDaySlots } from './dayService';\nimport { EMPTY_RESOURCE } from '../constants';\nimport { expandResources, toGroupResources } from '../views/common/utils';\n/** @hidden */\n\nexport var toTimeSlots = function (intl, group, resources, ranges, timezone, showWorkHours, props) {\n  var slots = [];\n  var groupResources = toGroupResources(group, resources);\n  var expandedResources = expandResources(groupResources || [], (groupResources || []).length - 1);\n  var hasGroups = expandedResources.length > 0;\n  (hasGroups ? expandedResources : EMPTY_RESOURCE).forEach(function (_, groupIndex) {\n    return ranges.map(function (range, rangeIndex) {\n      generateTimeSlots(intl, range.start, range.end, timezone, showWorkHours, props).map(function (slot) {\n        slots.push(__assign({}, slot, {\n          groupIndex: hasGroups ? groupIndex : undefined,\n          rangeIndex: rangeIndex\n        }));\n      });\n    });\n  });\n  return slots;\n};\n/** @hidden */\n\nexport var toTimeItems = function (_a) {\n  var rangeStart = _a.rangeStart,\n      rangeEnd = _a.rangeEnd,\n      ranges = _a.ranges,\n      data = _a.data,\n      timezone = _a.timezone;\n  var items = [];\n  var sorted = orderBy(data, [{\n    field: 'isAllDay',\n    dir: 'desc'\n  }, {\n    field: 'start',\n    dir: 'asc'\n  }, {\n    field: 'end',\n    dir: 'desc'\n  }]);\n\n  for (var index = 0; index < sorted.length; index++) {\n    var item = toTimeItem(sorted[index], {\n      timezone: timezone,\n      ranges: ranges,\n      rangeStart: rangeStart,\n      rangeEnd: rangeEnd\n    });\n\n    if (item) {\n      items.push(item);\n    }\n  }\n\n  return items;\n};\n/** @hidden */\n\nexport var toTimeItem = function (item, _a) {\n  var timezone = _a.timezone,\n      ranges = _a.ranges,\n      rangeStart = _a.rangeStart,\n      rangeEnd = _a.rangeEnd;\n  var isRecurring = Boolean(item.recurrenceRule);\n  var isException = item.recurrenceId !== undefined && item.recurrenceId !== null && !isRecurring;\n  var isAllDay = Boolean(item.isAllDay); // || isMultiDay(eventItem.dataItem);\n\n  if (intersects(item.start, item.end, rangeStart, rangeEnd)) {\n    var ref = React.createRef();\n    var end = isAllDay ? calculateEndInRanges(ranges, item.end) : item.end;\n    var start = isAllDay ? calculateStartInRanges(ranges, item.start) : item.start;\n    var zonedStart = ZonedDate.fromLocalDate(start, timezone);\n    var zonedEnd = ZonedDate.fromLocalDate(end, timezone);\n\n    var viewItem = __assign({}, item, {\n      ref: ref,\n      order: null,\n      slots: [],\n      ranges: ranges.filter(function (range) {\n        return intersects(item.start, item.end, range.start, range.end);\n      }),\n      start: start,\n      end: end,\n      zonedStart: zonedStart,\n      zonedEnd: zonedEnd,\n      isAllDay: isAllDay,\n      isException: isException,\n      isRecurring: isRecurring,\n      isEdge: false,\n      head: item.end > rangeEnd,\n      tail: item.start < rangeStart\n    });\n\n    return viewItem;\n  }\n\n  return null;\n};\n/** @hidden */\n\nexport var generateTimeSlots = function (intl, rangeStart, rangeEnd, timezone, showWorkHours, _a) {\n  var startTime = _a.startTime,\n      endTime = _a.endTime,\n      workDayStart = _a.workDayStart,\n      workDayEnd = _a.workDayEnd,\n      workWeekStart = _a.workWeekStart,\n      workWeekEnd = _a.workWeekEnd,\n      slotDivisions = _a.slotDivisions,\n      slotDuration = _a.slotDuration; // DO NOT TOUCH: Nobody knows how this works!\n  // AND make sure you pass the timezone as argument!\n\n  var rangeStartTime = intl.parseDate(showWorkHours ? workDayStart : startTime);\n  var rangeEndTime = intl.parseDate(showWorkHours ? workDayEnd : endTime);\n  var fullDay = rangeStartTime.getHours() === rangeEndTime.getHours() && rangeStartTime.getMinutes() === rangeEndTime.getMinutes();\n  var slots = [];\n  var base = rangeStart.getTime();\n  var step = Math.round(slotDuration / slotDivisions * MS_PER_MINUTE);\n  var total = rangeEnd.getTime() - rangeStart.getTime();\n  var index = 0;\n  var distance = 0;\n\n  while (distance < total) {\n    var ref = React.createRef();\n    var start = new Date(base + index * step);\n    var zonedStart = ZonedDate.fromLocalDate(start, timezone);\n    var end = new Date(base + (index + 1) * step);\n    var zonedEnd = ZonedDate.fromLocalDate(end, timezone);\n    var isMajor = index % slotDivisions === 0;\n    var isEdge = slots.length === 0;\n    var isAllDay = false;\n    var workStart = intl.parseDate(workDayStart);\n    var workEnd = intl.parseDate(workDayEnd);\n    var workHour = isInTimeRange(zonedStart, workStart, workEnd);\n    var workDay = workWeekStart <= zonedStart.getDay() && zonedStart.getDay() <= workWeekEnd;\n    var slot = {\n      ref: ref,\n      end: end,\n      index: index,\n      start: start,\n      isMajor: isMajor,\n      isEdge: isEdge,\n      isAllDay: isAllDay,\n      zonedStart: zonedStart,\n      zonedEnd: zonedEnd,\n      workHour: workHour,\n      workDay: workDay,\n      items: [],\n      rangeIndex: 0,\n      groupIndex: 0\n    };\n    distance += step;\n    index++;\n\n    if (isInTimeRange(zonedStart, rangeStartTime, rangeEndTime) || fullDay) {\n      slots.push(slot);\n    }\n  }\n\n  return slots;\n};\n\nvar isInTimeRange = function (date, min, max) {\n  return (min.getHours() < date.getHours() || min.getHours() === date.getHours() && min.getMinutes() <= date.getMinutes()) && (date.getHours() < max.getHours() || max.getHours() === date.getHours() && date.getMinutes() < max.getMinutes());\n};\n\nvar calculateStartInRanges = function (ranges, start) {\n  var result = start;\n  ranges.forEach(function (range) {\n    if (range.start.getDate() === start.getDate()) {\n      result = range.start;\n    }\n  });\n  return result;\n};\n\nvar calculateEndInRanges = function (ranges, end) {\n  var result = end;\n  ranges.forEach(function (range) {\n    if (range.start.getDate() === end.getDate() && range.start < end) {\n      result = range.end;\n    }\n  });\n  return result;\n};\n/** @hidden */\n\n\nexport var toTimeRanges = generateDaySlots;","map":null,"metadata":{},"sourceType":"module"}