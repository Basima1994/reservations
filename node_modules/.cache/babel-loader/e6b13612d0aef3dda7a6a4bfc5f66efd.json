{"ast":null,"code":"import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nvar logic = {\n  \"or\": {\n    concat: function (acc, fn) {\n      return function (a) {\n        return acc(a) || fn(a);\n      };\n    },\n    identity: function () {\n      return false;\n    }\n  },\n  \"and\": {\n    concat: function (acc, fn) {\n      return function (a) {\n        return acc(a) && fn(a);\n      };\n    },\n    identity: function () {\n      return true;\n    }\n  }\n};\nvar operatorsMap = {\n  contains: function (a, b) {\n    return (a || \"\").indexOf(b) >= 0;\n  },\n  doesnotcontain: function (a, b) {\n    return (a || \"\").indexOf(b) === -1;\n  },\n  doesnotendwith: function (a, b) {\n    return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0;\n  },\n  doesnotstartwith: function (a, b) {\n    return (a || \"\").lastIndexOf(b, 0) === -1;\n  },\n  endswith: function (a, b) {\n    return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0;\n  },\n  eq: function (a, b) {\n    return a === b;\n  },\n  gt: function (a, b) {\n    return a > b;\n  },\n  gte: function (a, b) {\n    return a >= b;\n  },\n  isempty: function (a) {\n    return a === '';\n  },\n  isnotempty: function (a) {\n    return a !== '';\n  },\n  isnotnull: function (a) {\n    return isPresent(a);\n  },\n  isnull: function (a) {\n    return isBlank(a);\n  },\n  lt: function (a, b) {\n    return a < b;\n  },\n  lte: function (a, b) {\n    return a <= b;\n  },\n  neq: function (a, b) {\n    return a != b;\n  },\n  startswith: function (a, b) {\n    return (a || \"\").lastIndexOf(b, 0) === 0;\n  }\n};\nvar dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\n\nvar convertValue = function (value, ignoreCase) {\n  if (value != null && isString(value)) {\n    var date = dateRegExp.exec(value);\n\n    if (date) {\n      return new Date(+date[1]).getTime();\n    } else if (ignoreCase) {\n      return value.toLowerCase();\n    }\n  } else if (value != null && isDate(value)) {\n    return value.getTime();\n  }\n\n  return value;\n};\n\nvar typedGetter = function (prop, value, ignoreCase) {\n  if (!isPresent(value)) {\n    return prop;\n  }\n\n  var acc = prop;\n\n  if (isString(value)) {\n    var date = dateRegExp.exec(value);\n\n    if (date) {\n      value = new Date(+date[1]);\n    } else {\n      acc = function (a) {\n        var x = prop(a);\n\n        if (typeof x === 'string' && ignoreCase) {\n          return x.toLowerCase();\n        } else {\n          return isNumeric(x) ? x + \"\" : x;\n        }\n      };\n    }\n  }\n\n  if (isDate(value)) {\n    return function (a) {\n      var x = acc(a);\n      return isDate(x) ? x.getTime() : x;\n    };\n  }\n\n  return acc;\n};\n\nvar transformFilter = function (_a) {\n  var field = _a.field,\n      ignoreCase = _a.ignoreCase,\n      value = _a.value,\n      operator = _a.operator;\n  field = !isPresent(field) ? function (a) {\n    return a;\n  } : field;\n  ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n  var itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n  value = convertValue(value, ignoreCase);\n  var op = isFunction(operator) ? operator : operatorsMap[operator];\n  return function (a) {\n    return op(itemProp(a), value, ignoreCase);\n  };\n};\n/**\n * @hidden\n */\n\n\nexport var transformCompositeFilter = function (filter) {\n  var combiner = logic[filter.logic];\n  return filter.filters.filter(isPresent).map(function (x) {\n    return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x);\n  }).reduce(combiner.concat, combiner.identity);\n};","map":null,"metadata":{},"sourceType":"module"}