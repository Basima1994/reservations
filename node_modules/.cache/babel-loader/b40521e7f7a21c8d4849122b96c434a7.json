{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { DatePicker } from '@progress/kendo-react-dateinputs';\nimport { NumericTextBox } from '@progress/kendo-react-inputs';\nimport { getUntilEnd, getUntilMin } from './common';\nimport { toUTCDate } from '../../utils';\nimport { ZonedDate } from '@progress/kendo-date-math';\nvar RADIO_ATTRIBUTES = {\n  type: 'radio',\n  name: 'end',\n  className: 'k-radio'\n};\n/** @hidden */\n\nexport var RecurrenceEndEditor = function (props) {\n  var titleClassName = props.titleClassName,\n      editorClassName = props.editorClassName,\n      title = props.title,\n      endRule = props.endRule,\n      endNever = props.endNever,\n      endAfter = props.endAfter,\n      endOn = props.endOn,\n      onEndRuleChange = props.onEndRuleChange,\n      start = props.start,\n      endOccurrence = props.endOccurrence,\n      onUntilChange = props.onUntilChange,\n      onCountChange = props.onCountChange,\n      timezone = props.timezone;\n  var count = props.count || 1;\n  var until = getUntilEnd(start, props.until);\n  var untilMin = getUntilMin(start, props.until);\n  var onChangeHandler = React.useCallback(function (e) {\n    onEndRuleChange({\n      value: e.target.value,\n      count: count,\n      until: until\n    });\n  }, [onEndRuleChange]);\n  var onUntilChangeHandler = React.useCallback(function (event) {\n    // Read the until date as UTC date parts to avoid interfering with the local time zone.\n    var newUntil = toUTCDate(event.target.value);\n    newUntil.setUTCDate(newUntil.getUTCDate() + 1); // Convert to the scheduler time zone.\n\n    onUntilChange(ZonedDate.fromUTCDate(newUntil, timezone).toLocalDate());\n  }, [onUntilChange]);\n  var onCountChangeHandler = React.useCallback(function (event) {\n    onCountChange(event.target.value);\n  }, [onCountChange]);\n  return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n    className: titleClassName\n  }, title), React.createElement(\"div\", {\n    className: editorClassName\n  }, React.createElement(\"ul\", {\n    className: \"k-reset\"\n  }, React.createElement(\"li\", null, React.createElement(\"input\", __assign({}, RADIO_ATTRIBUTES, {\n    checked: endRule === 'never',\n    id: 'k-endrule-never',\n    onChange: onChangeHandler,\n    value: 'never'\n  })), React.createElement(\"label\", {\n    className: 'k-radio-label',\n    htmlFor: 'k-endrule-never'\n  }, endNever)), React.createElement(\"li\", null, React.createElement(\"input\", __assign({}, RADIO_ATTRIBUTES, {\n    checked: endRule === 'count',\n    id: 'k-endrule-count',\n    onChange: onChangeHandler,\n    value: 'count'\n  })), React.createElement(\"label\", {\n    className: 'k-radio-label',\n    htmlFor: 'k-endrule-count'\n  }, endAfter), \"\\u00A0\", React.createElement(NumericTextBox, {\n    width: 70,\n    disabled: endRule !== 'count',\n    min: 1,\n    value: count,\n    onChange: onCountChangeHandler\n  }), \"\\u00A0\", React.createElement(\"span\", null, endOccurrence)), React.createElement(\"li\", null, React.createElement(\"input\", __assign({}, RADIO_ATTRIBUTES, {\n    checked: endRule === 'until',\n    id: 'k-endrule-until',\n    onChange: onChangeHandler,\n    value: 'until'\n  })), React.createElement(\"label\", {\n    className: 'k-radio-label',\n    htmlFor: 'k-endrule-until'\n  }, endOn), \"\\u00A0\", React.createElement(DatePicker, {\n    width: 150,\n    disabled: endRule !== 'until',\n    min: untilMin,\n    value: until,\n    onChange: onUntilChangeHandler\n  })))));\n};","map":null,"metadata":{},"sourceType":"module"}