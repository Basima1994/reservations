{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { getDate } from '@progress/kendo-date-math';\nimport { toGroupResources, toFlatGroupResources } from '../views/common/utils';\nimport { getter, setter, clone, cloneDate } from '@progress/kendo-react-common';\nimport { // OCCURRENCE_ID,\nDEFAULT_ID } from '../constants';\nexport * from './toSchedulerItems';\nexport * from './toDataItem';\n/** @hidden */\n\nexport var first = function (arr) {\n  return arr[0];\n};\n/** @hidden */\n\nexport var last = function (arr) {\n  return arr[arr.length - 1];\n};\n/** @hidden */\n\nexport var isMultiDay = function (item) {\n  var result = item.end.getTime() - item.start.getTime() > new Date(0).setHours(24);\n  return result;\n};\n/**\n * @hidden\n * TODO Move to date-math\n */\n\nexport var addUTCDays = function (date, offset) {\n  var newDate = new Date(date.getTime());\n  newDate.setUTCDate(newDate.getUTCDate() + offset);\n  return newDate;\n};\n/** @hidden */\n\nexport function dateWithTime(target, time) {\n  return new Date(target.getFullYear(), target.getMonth(), target.getDate(), time.getHours(), time.getMinutes());\n}\n/**\n * @hidden\n */\n\nexport var getToday = function () {\n  return getDate(new Date());\n}; // Introduce max depth doe to Maximum call stack size exceeded when react <body />\n// The element.closest() approach is not available due to browser support issues.\n\n/** @hidden */\n\nexport var slotDive = function (x, y, maxDepth, level) {\n  if (level === void 0) {\n    level = 0;\n  }\n\n  if (level === maxDepth) {\n    return null;\n  }\n\n  var result = null;\n  var element = document.elementFromPoint(x, y);\n\n  if (!element) {\n    return result;\n  }\n\n  var isSlot = element.getAttribute('data-slot') === 'true';\n\n  if (isSlot) {\n    return element;\n  } else {\n    var oldPointerEvents = element.style.pointerEvents;\n    element.style.pointerEvents = 'none';\n    result = slotDive(x, y, maxDepth, level + 1);\n    element.style.pointerEvents = oldPointerEvents;\n  }\n\n  return result;\n};\n/**\n * @hidden\n */\n\nexport var getField = function (obj, field) {\n  return getter(field)(obj);\n};\n/**\n * @hidden\n */\n\nexport var setField = function (obj, field, value) {\n  if (!field) {\n    return;\n  }\n\n  return setter(field)(obj, value);\n};\n/**\n * @hidden\n */\n\nexport function assignField(target, source, field) {\n  setField(target, field, getField(source, field));\n}\n/**\n * @hidden\n */\n\nexport function assignFields(target, source) {\n  var fields = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    fields[_i - 2] = arguments[_i];\n  }\n\n  for (var idx = 0; idx < fields.length; idx++) {\n    assignField(target, source, fields[idx]);\n  }\n}\n/**\n * @hidden\n */\n\nexport var isPresent = function (value) {\n  return value !== null && value !== undefined;\n};\n/** @hidden */\n\nexport var isInGroup = function (item, group, resources) {\n  var groupedResources = toGroupResources(group, resources);\n\n  if (!groupedResources || !groupedResources.length) {\n    return true;\n  }\n\n  return item.groups.length > 0;\n};\n/**\n * @hidden\n */\n\nexport var isRecurringMaster = function (event) {\n  return event.recurrenceRule && !isPresent(event.recurrenceId);\n}; //  TODO: move to date-math\n\n/** @hidden */\n\nexport function toUTCDate(localDate) {\n  return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate()));\n} // TODO: move to date-math\n\n/** @hidden */\n\nexport function getUTCDate(utcDate) {\n  return new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));\n} // TODO: move to date-math\n\n/** @hidden */\n\nexport function toUTCDateTime(localDate) {\n  return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));\n}\n/** @hidden */\n\nexport function toInvariantTime(date) {\n  var staticDate = new Date(1980, 1, 1, 0, 0, 0);\n\n  if (date) {\n    staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n  }\n\n  return staticDate;\n}\n/** @hidden */\n\nexport function isRecurringException(event) {\n  return event && isPresent(event.recurrenceId) && !event.recurrenceRule;\n}\n/**\n * @hidden\n */\n\nexport var isRecurring = function (event, fields) {\n  var recurrenceId = getter(fields.recurrenceId || 'recurrenceId')(event);\n  var recurrenceRule = getter(fields.recurrenceRule || 'recurrenceRule')(event);\n  return !!(recurrenceRule || recurrenceId);\n};\n/**\n * @hidden\n */\n\nexport var groupResources = function (group, resources) {\n  var result = [];\n\n  if (group && group.resources && group.resources.length) {\n    var groups_1 = group.resources;\n\n    var _loop_1 = function (idx) {\n      var resource = resources.find(function (r) {\n        return r.name === groups_1[idx];\n      });\n      result.push(resource);\n    };\n\n    for (var idx = 0; idx < groups_1.length; idx++) {\n      _loop_1(idx);\n    }\n  }\n\n  return result;\n};\n/**\n * @hidden\n */\n\nexport var findMaster = function (event, fields, data) {\n  var headId = isMaster(event, fields) ? getField(event, fields.id) : getField(event, fields.recurrenceId);\n  return data.find(function (currentEvent) {\n    return getField(currentEvent, fields.id) === headId;\n  });\n};\n/**\n * @hidden\n */\n\nexport var isMaster = function (event, fields) {\n  var id = getField(event, fields.id);\n  var recurrenceRule = getField(event, fields.recurrenceRule);\n  var recurrenceId = getField(event, fields.recurrenceId);\n  return !!(id && recurrenceRule && (recurrenceId === undefined || recurrenceId === null));\n};\n/**\n * @hidden\n */\n\nexport var buildException = function (event, fields, data) {\n  var headEvent = findMaster(event, fields, data);\n  var copy = clone(event);\n  assignField(copy, headEvent, fields.id);\n\n  if (fields.id !== undefined) {\n    setField(copy, fields.id, DEFAULT_ID);\n  }\n\n  if (fields.recurrenceRule !== undefined) {\n    setField(copy, fields.recurrenceRule, undefined);\n  }\n\n  if (fields.recurrenceId !== undefined) {\n    setField(copy, fields.recurrenceId, getField(headEvent, fields.id));\n  }\n\n  return copy;\n};\n/**\n * @hidden\n */\n\nexport var isException = function (event, fields) {\n  return isPresent(getField(event, fields.recurrenceId)) && !getField(event, fields.recurrenceRule);\n};\n\nvar maxDate = function (x, y) {\n  return Math.max(x.getTime(), y.getTime());\n};\n\nvar minDate = function (x, y) {\n  return Math.min(x.getTime(), y.getTime());\n};\n/** @hidden */\n\n\nexport var intersects = function (startTime, endTime, periodStart, periodEnd) {\n  return maxDate(endTime, periodEnd) - minDate(startTime, periodStart) < endTime.getTime() - startTime.getTime() + (periodEnd.getTime() - periodStart.getTime());\n};\n/** @hidden */\n\nexport var roundAllDayEnd = function (_a) {\n  var start = _a.start,\n      end = _a.end;\n  var startDate = start.stripTime();\n  var endDate = end.stripTime();\n  return endDate.getTime() !== end.getTime() || startDate.getTime() === endDate.getTime() ? endDate.addDays(1) : endDate;\n};\n/**\n * @hidden\n */\n\nexport var defaultModelFields = {\n  id: 'id',\n  start: 'start',\n  startTimezone: 'startTimezone',\n  end: 'end',\n  endTimezone: 'endTimezone',\n  isAllDay: 'isAllDay',\n  title: 'title',\n  description: 'description',\n  recurrenceRule: 'recurrenceRule',\n  recurrenceId: 'recurrenceId',\n  recurrenceExceptions: 'recurrenceExceptions'\n};\n/** @hidden */\n\nexport var getModelFields = function (modelFields) {\n  return {\n    fields: __assign({}, defaultModelFields, modelFields)\n  };\n};\n/** @hidden */\n\nexport var generateGroups = function (groupIndex, nextGroupIndex, groups, group, resources) {\n  if (resources === void 0) {\n    resources = [];\n  }\n\n  if (!groupIndex || !nextGroupIndex) {\n    return [];\n  }\n\n  var groupedResources = toGroupResources(group, resources);\n  var flat = toFlatGroupResources(groupedResources);\n  return groups.map(function (g) {\n    return g.index === Number(groupIndex) ? {\n      index: Number(nextGroupIndex),\n      resources: flat[Number(nextGroupIndex)]\n    } : g;\n  });\n};\n/** @hidden */\n\nexport var generateResourceFields = function (groups, defaultFields) {\n  if (!groups || !groups.length) {\n    return defaultFields;\n  }\n\n  var result = {};\n  groups.forEach(function (group) {\n    group.resources.forEach(function (resource) {\n      if (result[resource.field] === undefined) {\n        result[resource.field] = resource[resource.valueField];\n      }\n    });\n  });\n  return result;\n};\n/**\n * @hidden\n *\n * TODO: Move to @progress/kendo-common\n */\n\nexport var capitalize = function (value) {\n  return value.charAt(0).toUpperCase() + value.slice(1);\n};\n/**\n * @hidden\n *\n * TODO: Move to @progress/kendo-common\n */\n\nexport var isBlank = function (value) {\n  return value === null || value === undefined;\n};\n/**\n * @hidden\n *\n * TODO: Move to @progress/kendo-common\n */\n\nexport var isNullOrEmptyString = function (value) {\n  return isBlank(value) || value.trim && value.trim().length === 0;\n};\n/**\n * @hidden\n */\n\nexport var setTime = function (origin, candidate) {\n  var date = cloneDate(origin);\n  date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());\n  return date;\n};\n\nfunction getDataIdx(value, resource) {\n  var data = resource.data;\n\n  for (var dataIdx = 0; dataIdx < data.length; dataIdx++) {\n    if (getField(data[dataIdx], resource.valueField) === value) {\n      return dataIdx;\n    }\n  }\n\n  return 0;\n}\n/** @hidden */\n\n\nexport var extractGroups = function (dataItem, fields, group, resources) {\n  var groupedResources = toGroupResources(group, resources);\n  var flat = toFlatGroupResources(groupedResources);\n\n  var flatGroupsReducer = function (acc, items, index) {\n    var match = true;\n    items.forEach(function (item) {\n      var expected = item[item.valueField];\n      var actual = dataItem[fields[item.field] || item.field];\n\n      if (Array.isArray(actual)) {\n        match = match && actual.indexOf(expected) >= 0;\n      } else {\n        match = match && actual === expected;\n      }\n    });\n\n    if (match) {\n      return acc.concat([{\n        index: index,\n        resources: items\n      }]);\n    } else {\n      return acc;\n    }\n  };\n\n  return flat.reduce(flatGroupsReducer, []);\n};\n\nvar findLeafResource = function (level) {\n  if (level === void 0) {\n    level = 0;\n  }\n\n  return findLeafResource(level + 1);\n};\n/** @hidden */\n\n\nexport var extractResourceFields = function (dataItem, fields, resources) {\n  var result = {};\n\n  if (!resources || !resources.length) {\n    return result;\n  }\n\n  resources.forEach(function (resource) {\n    var match = resource.data.find(function (item) {\n      return item.value === dataItem[fields[resource.field] || resource.field];\n    });\n\n    if (match) {\n      result[resource.field] = match.value;\n    }\n  });\n  return result;\n};\n/** @hidden */\n\nexport var extractResources = function (dataItem, fields, resources) {\n  if (resources === void 0) {\n    resources = [];\n  }\n\n  var resourceIndex = 0;\n  var itemResources = [];\n\n  for (var resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {\n    var resource = resources[resourceIdx];\n    var values = getField(dataItem, fields[resource.field] || resource.field);\n\n    if (!Array.isArray(values)) {\n      values = [values];\n    }\n\n    for (var valueIndex = 0; valueIndex < values.length; valueIndex++) {\n      if (values[valueIndex] !== undefined) {\n        var dataIdx = getDataIdx(values[valueIndex], resource);\n        var data = resource.data[dataIdx];\n        var itemResource = {\n          text: getField(data, resource.textField),\n          color: getField(data, resource.colorField),\n          value: getField(data, resource.valueField)\n        };\n        itemResources.push(__assign({}, itemResource, {\n          index: resourceIndex\n        }));\n      }\n\n      resourceIndex++;\n    }\n  }\n\n  return itemResources;\n}; // Change from JSON.stringify to recursive compare! use clone\n\n/** @hidden */\n\nexport var shallowCompare = function (x, y) {\n  return JSON.stringify(x) === JSON.stringify(y);\n};\n/** @hidden */\n\nexport var snapToSlot = function (item, slot) {\n  var duration = item.end.getTime() - item.start.getTime();\n  return __assign({}, item, {\n    isAllDay: slot.isAllDay,\n    start: new Date(slot.start.getTime()),\n    end: new Date(slot.start.getTime() + duration)\n  });\n};\n/** @hidden */\n\nexport var findMissing = function (orderNumbers) {\n  var result = 0; // Array.find is also O(n)\n\n  orderNumbers.forEach(function (_, index) {\n    if (orderNumbers[index] === index) {\n      result = index + 1;\n    }\n  });\n  return result;\n}; // TODO: REVISIT\n\n/** @hidden */\n\nexport var mapSlotsToItems = function (items, slots, ignoreIsAllDay) {\n  if (ignoreIsAllDay === void 0) {\n    ignoreIsAllDay = false;\n  } // Clear\n\n\n  slots.forEach(function (slot) {\n    return slot.items.splice(0, slot.items.length);\n  }); // Populate\n\n  slots.forEach(function (slot) {\n    var orderNumbers = [];\n    items.forEach(function (item) {\n      var fit = (ignoreIsAllDay || item.isAllDay === slot.isAllDay) && (!item.groups.length || item.groups.find(function (group) {\n        return group.index === slot.groupIndex;\n      }) !== undefined) && intersects(item.start, item.end, slot.start, slot.end);\n\n      if (fit) {\n        var order = findMissing(orderNumbers);\n\n        if (item.order === null || item.order < order) {\n          item.order = order;\n        }\n\n        orderNumbers.push(item.order);\n        slot.items.push(item);\n      }\n    });\n  });\n}; // TODO: REVISIT\n\n/** @hidden */\n\nexport var mapItemsToSlots = function (items, slots, ignoreIsAllDay) {\n  if (ignoreIsAllDay === void 0) {\n    ignoreIsAllDay = false;\n  } // Clear\n\n\n  items.forEach(function (item) {\n    return item.slots.splice(0, item.slots.length);\n  }); // Populate\n\n  items.forEach(function (item) {\n    slots.forEach(function (slot) {\n      var fit = (ignoreIsAllDay || item.isAllDay === slot.isAllDay) && (!item.groups.length || item.groups.find(function (group) {\n        return group.index === slot.groupIndex;\n      }) !== undefined) && intersects(item.start, item.end, slot.start, slot.end);\n\n      if (fit) {\n        item.slots.push(slot);\n      }\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"module"}